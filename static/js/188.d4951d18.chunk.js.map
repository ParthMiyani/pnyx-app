{"version":3,"file":"static/js/188.d4951d18.chunk.js","mappings":"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","sources":["../node_modules/@thirdweb-dev/sdk/dist/QueryParams-489c04ee.browser.esm.js","../node_modules/@thirdweb-dev/sdk/dist/contract-owner-29132da9.browser.esm.js"],"sourcesContent":["import { C as CommonNFTOutput, a as CommonNFTInput } from './setErc20Allowance-4ec0c078.browser.esm.js';\nimport { utils, BigNumber, Contract } from 'ethers';\nimport 'zod';\n\n/**\n * @internal\n */\n\n/**\n * @internal\n */\nconst InterfaceId_IERC721 = /* @__PURE__ */(() => utils.arrayify(\"0x80ac58cd\"))();\n\n/**\n * @internal\n */\nconst InterfaceId_IERC1155 = /* @__PURE__ */(() => utils.arrayify(\"0xd9b67a26\"))();\n\nconst FALLBACK_METADATA = {\n  name: \"Failed to load NFT metadata\"\n};\n\n/**\n * fetches the token metadata\n * @param tokenId - the id (to get it back in the output)\n * @param tokenUri - the uri to fetch\n * @param storage - which storage to fetch from\n *\n * @internal\n */\nasync function fetchTokenMetadata(tokenId, tokenUri, storage) {\n  // check for base64 encoded JSON\n  if (tokenUri.startsWith(\"data:application/json;base64\") && typeof Buffer !== \"undefined\") {\n    const base64 = tokenUri.split(\",\")[1];\n    const jsonMetadata = JSON.parse(Buffer.from(base64, \"base64\").toString(\"utf-8\"));\n    return CommonNFTOutput.parse({\n      ...jsonMetadata,\n      id: BigNumber.from(tokenId).toString(),\n      uri: tokenUri\n    });\n  }\n  // handle dynamic id URIs (2 possible formats)\n  const parsedUri = tokenUri.replace(\"{id}\", utils.hexZeroPad(BigNumber.from(tokenId).toHexString(), 32).slice(2));\n  let jsonMetadata;\n  try {\n    jsonMetadata = await storage.downloadJSON(parsedUri);\n  } catch (err) {\n    const unparsedTokenIdUri = tokenUri.replace(\"{id}\", BigNumber.from(tokenId).toString());\n    try {\n      jsonMetadata = await storage.downloadJSON(unparsedTokenIdUri);\n    } catch (e) {\n      console.warn(`failed to get token metadata: ${JSON.stringify({\n        tokenId: tokenId.toString(),\n        tokenUri\n      })} -- falling back to default metadata`);\n      jsonMetadata = FALLBACK_METADATA;\n    }\n  }\n  return CommonNFTOutput.parse({\n    ...jsonMetadata,\n    id: BigNumber.from(tokenId).toString(),\n    uri: tokenUri\n  });\n}\n\n// Used for marketplace to fetch NFT metadata from contract address + tokenId\n/**\n * @internal\n * @param contractAddress - the contract address\n * @param provider - the provider to use\n * @param tokenId - the token id\n * @param storage - the storage to use\n */\nasync function fetchTokenMetadataForContract(contractAddress, provider, tokenId, storage) {\n  let uri;\n  const ERC165MetadataAbi = (await import('@thirdweb-dev/contracts-js/dist/abis/IERC165.json')).default;\n  const erc165 = new Contract(contractAddress, ERC165MetadataAbi, provider);\n  const [isERC721, isERC1155] = await Promise.all([erc165.supportsInterface(InterfaceId_IERC721), erc165.supportsInterface(InterfaceId_IERC1155)]);\n  if (isERC721) {\n    const ERC721MetadataAbi = (await import('@thirdweb-dev/contracts-js/dist/abis/IERC721Metadata.json')).default;\n    const erc721 = new Contract(contractAddress, ERC721MetadataAbi, provider);\n    uri = await erc721.tokenURI(tokenId);\n  } else if (isERC1155) {\n    const ERC1155MetadataAbi = (await import('@thirdweb-dev/contracts-js/dist/abis/IERC1155Metadata.json')).default;\n    const erc1155 = new Contract(contractAddress, ERC1155MetadataAbi, provider);\n    uri = await erc1155.uri(tokenId);\n  } else {\n    throw Error(\"Contract must implement ERC 1155 or ERC 721.\");\n  }\n  if (!uri) {\n    // no uri found, return fallback metadata\n    return CommonNFTOutput.parse({\n      ...FALLBACK_METADATA,\n      id: BigNumber.from(tokenId).toString(),\n      uri: \"\"\n    });\n  }\n  return fetchTokenMetadata(tokenId, uri, storage);\n}\n\n/**\n * @internal\n * @param metadata - the metadata to upload\n * @param storage - the storage to use\n */\nasync function uploadOrExtractURI(metadata, storage) {\n  if (typeof metadata === \"string\") {\n    return metadata;\n  } else {\n    return await storage.upload(CommonNFTInput.parse(metadata));\n  }\n}\n\n/**\n * @internal\n * @param metadatas - the metadata to upload\n * @param storage - the storage to use\n * @param startNumber - the number to start the file names at\n * @param contractAddress - the contract address\n * @param signerAddress - the signer address\n * @param options - options\n */\nasync function uploadOrExtractURIs(metadatas, storage, startNumber, options) {\n  if (isUriList(metadatas)) {\n    return metadatas;\n  } else if (isMetadataList(metadatas)) {\n    const uris = await storage.uploadBatch(metadatas.map(m => CommonNFTInput.parse(m)), {\n      rewriteFileNames: {\n        fileStartNumber: startNumber || 0\n      },\n      onProgress: options?.onProgress\n    });\n    return uris;\n  } else {\n    throw new Error(\"NFT metadatas must all be of the same type (all URI or all NFTMetadataInput)\");\n  }\n}\nfunction getBaseUriFromBatch(uris) {\n  const baseUri = uris[0].substring(0, uris[0].lastIndexOf(\"/\"));\n  for (let i = 0; i < uris.length; i++) {\n    const uri = uris[i].substring(0, uris[i].lastIndexOf(\"/\"));\n    if (baseUri !== uri) {\n      throw new Error(`Can only create batches with the same base URI for every entry in the batch. Expected '${baseUri}' but got '${uri}'`);\n    }\n  }\n\n  // Ensure that baseUri ends with trailing slash\n  return baseUri.replace(/\\/$/, \"\") + \"/\";\n}\nfunction isUriList(metadatas) {\n  return metadatas.find(m => typeof m !== \"string\") === undefined;\n}\nfunction isMetadataList(metadatas) {\n  return metadatas.find(m => typeof m !== \"object\") === undefined;\n}\n\n/**\n * @internal\n */\nconst DEFAULT_QUERY_ALL_COUNT = 100;\n\n/**\n * Pagination Parameters\n * @public\n */\n\nexport { DEFAULT_QUERY_ALL_COUNT as D, FALLBACK_METADATA as F, InterfaceId_IERC721 as I, InterfaceId_IERC1155 as a, uploadOrExtractURI as b, fetchTokenMetadataForContract as c, fetchTokenMetadata as f, getBaseUriFromBatch as g, uploadOrExtractURIs as u };\n","import { h as hasFunction } from './contract-appuri-8a73f5ec.browser.esm.js';\nimport { d as buildTransactionFunction, T as Transaction } from './transactions-d1b63e67.browser.esm.js';\nimport { d1 as FEATURE_ROYALTY, bD as CommonRoyaltySchema, aV as NATIVE_TOKEN_ADDRESS, d2 as FEATURE_OWNER, aL as resolveAddress } from './index-c67c8d87.browser.esm.js';\nimport { C as ContractEncoder } from './fetchCurrencyValue-ca929de6.browser.esm.js';\nimport { utils, BigNumber, Contract } from 'ethers';\nimport { a as CommonNFTInput } from './setErc20Allowance-4ec0c078.browser.esm.js';\nimport { c as fetchTokenMetadataForContract, g as getBaseUriFromBatch } from './QueryParams-489c04ee.browser.esm.js';\nimport { a as approveErc20Allowance } from './signature-74888765.browser.esm.js';\nimport { n as normalizePriceValue } from './normalizePriceValue-2bd5325b.browser.esm.js';\n\n/**\n * Handle contract royalties\n * @remarks Configure royalties for an entire contract or a particular token.\n * @example\n * ```javascript\n * const contract = await sdk.getContract(\"{{contract_address}}\");\n * const royaltyInfo = await contract.royalties.getDefaultRoyaltyInfo();\n * await contract.roles.setTokenRoyaltyInfo(tokenId, {\n *   seller_fee_basis_points: 100, // 1% royalty fee\n *   fee_recipient: \"0x...\", // the fee recipient\n * });\n * ```\n * @public\n */\nclass ContractRoyalty {\n  featureName = FEATURE_ROYALTY.name;\n  constructor(contractWrapper, metadata) {\n    this.contractWrapper = contractWrapper;\n    this.metadata = metadata;\n  }\n\n  /**\n   * Get the royalty recipient and fee\n   * @returns  The royalty recipient and BPS\n   * @example\n   * ```javascript\n   * const royaltyInfo = await contract.royalties.getDefaultRoyaltyInfo();\n   * console.log(royaltyInfo.fee_recipient);\n   * console.log(royaltyInfo.seller_fee_basis_points);\n   * ```\n   * @public\n   * @twfeature Royalty\n   */\n  async getDefaultRoyaltyInfo() {\n    const [royaltyRecipient, royaltyBps] = await this.contractWrapper.read(\"getDefaultRoyaltyInfo\", []);\n    // parse it on the way out to make sure we default things if they are not set\n    return CommonRoyaltySchema.parseAsync({\n      fee_recipient: royaltyRecipient,\n      seller_fee_basis_points: royaltyBps\n    });\n  }\n\n  /**\n   * Get the royalty recipient and fee of a particular token\n   * @returns  The royalty recipient and BPS\n   * @example\n   * ```javascript\n   * const royaltyInfo = await contract.royalties.getDefaultRoyaltyInfo();\n   * console.log(royaltyInfo.fee_recipient);\n   * console.log(royaltyInfo.seller_fee_basis_points);\n   * ```\n   * @public\n   * @twfeature Royalty\n   */\n  async getTokenRoyaltyInfo(tokenId) {\n    const [royaltyRecipient, royaltyBps] = await this.contractWrapper.read(\"getRoyaltyInfoForToken\", [tokenId]);\n    return CommonRoyaltySchema.parseAsync({\n      fee_recipient: royaltyRecipient,\n      seller_fee_basis_points: royaltyBps\n    });\n  }\n\n  /**\n   * Set the royalty recipient and fee\n   * @param royaltyData - the royalty recipient and fee\n   *  @example\n   * ```javascript\n   * await contract.roles.setDefaultRoyaltyInfo({\n   *   seller_fee_basis_points: 100, // 1% royalty fee\n   *   fee_recipient: \"0x...\", // the fee recipient\n   * });\n   * ```\n   * @public\n   * @twfeature Royalty\n   */\n  setDefaultRoyaltyInfo = /* @__PURE__ */buildTransactionFunction(async royaltyData => {\n    // read the metadata from the contract\n    const oldMetadata = await this.metadata.get();\n\n    // update the metadata with the new royalty data\n    // if one of the keys is \"undefined\" it will be ignored (which is the desired behavior)\n    const mergedMetadata = await this.metadata.parseInputMetadata({\n      ...oldMetadata,\n      ...royaltyData\n    });\n\n    // why not use this.metadata.set()? - because that would end up sending it's own separate transaction to `setContractURI`\n    // but we want to send both the `setRoyaltyInfo` and `setContractURI` in one transaction!\n    const contractURI = await this.metadata._parseAndUploadMetadata(mergedMetadata);\n    if (hasFunction(\"setContractURI\", this.contractWrapper)) {\n      const contractEncoder = new ContractEncoder(this.contractWrapper);\n      // encode both the functions we want to send\n      const encoded = [contractEncoder.encode(\"setDefaultRoyaltyInfo\", [mergedMetadata.fee_recipient, mergedMetadata.seller_fee_basis_points]), contractEncoder.encode(\"setContractURI\", [contractURI])];\n      // actually send the transaction and return the receipt + a way to get the new royalty info\n\n      return Transaction.fromContractWrapper({\n        contractWrapper: this.contractWrapper,\n        method: \"multicall\",\n        args: [encoded],\n        parse: receipt => ({\n          receipt,\n          data: () => this.getDefaultRoyaltyInfo()\n        })\n      });\n    } else {\n      throw new Error(\"Updating royalties requires implementing ContractMetadata in your contract to support marketplaces like OpenSea.\");\n    }\n  });\n\n  /**\n   * Set the royalty recipient and fee for a particular token\n   * @param tokenId - the token id\n   * @param royaltyData - the royalty recipient and fee\n   * @example\n   * ```javascript\n   * const tokenId = 0;\n   * await contract.roles.setTokenRoyaltyInfo(tokenId, {\n   *   seller_fee_basis_points: 100, // 1% royalty fee\n   *   fee_recipient: \"0x...\", // the fee recipient\n   * });\n   * ```\n   * @public\n   * @twfeature Royalty\n   */\n  setTokenRoyaltyInfo = /* @__PURE__ */buildTransactionFunction(async (tokenId, royaltyData) => {\n    const parsedRoyaltyData = CommonRoyaltySchema.parse(royaltyData);\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"setRoyaltyInfoForToken\",\n      args: [tokenId, parsedRoyaltyData.fee_recipient, parsedRoyaltyData.seller_fee_basis_points],\n      parse: receipt => ({\n        receipt,\n        data: () => this.getDefaultRoyaltyInfo()\n      })\n    });\n  });\n}\n\n/**\n * Handles delayed reveal logic\n * @public\n */\nclass DelayedReveal {\n  constructor(contractWrapper, storage, featureName, nextTokenIdToMintFn) {\n    this.featureName = featureName;\n    this.nextTokenIdToMintFn = nextTokenIdToMintFn;\n    this.contractWrapper = contractWrapper;\n    this.storage = storage;\n  }\n\n  /**\n   * Create a batch of encrypted NFTs that can be revealed at a later time.\n   * @remarks Create a batch of encrypted NFTs that can be revealed at a later time.\n   * @example\n   * ```javascript\n   * // the real NFTs, these will be encrypted until your reveal them!\n   * const realNFTs = [{\n   *   name: \"Common NFT #1\",\n   *   description: \"Common NFT, one of many.\",\n   *   image: fs.readFileSync(\"path/to/image.png\"),\n   * }, {\n   *   name: \"Super Rare NFT #2\",\n   *   description: \"You got a Super Rare NFT!\",\n   *   image: fs.readFileSync(\"path/to/image.png\"),\n   * }];\n   * // A placeholder NFT that people will get immediately in their wallet, until the reveal happens!\n   * const placeholderNFT = {\n   *   name: \"Hidden NFT\",\n   *   description: \"Will be revealed next week!\"\n   * };\n   * // Create and encrypt the NFTs\n   * await contract.revealer.createDelayedRevealBatch(\n   *   placeholderNFT,\n   *   realNFTs,\n   *   \"my secret password\",\n   * );\n   * ```\n   * @public\n   * @param placeholder - the placeholder NFT to show before the reveal\n   * @param metadatas - the final NFTs that will be hidden\n   * @param password - the password that will be used to reveal these NFTs\n   * @param options - additional options like upload progress\n   */\n  createDelayedRevealBatch = /* @__PURE__ */buildTransactionFunction(async (placeholder, metadatas, password, options) => {\n    if (!password) {\n      throw new Error(\"Password is required\");\n    }\n    const placeholderUris = await this.storage.uploadBatch([CommonNFTInput.parse(placeholder)], {\n      rewriteFileNames: {\n        fileStartNumber: 0\n      }\n    });\n    const placeholderUri = getBaseUriFromBatch(placeholderUris);\n    const startFileNumber = await this.nextTokenIdToMintFn();\n    const uris = await this.storage.uploadBatch(metadatas.map(m => CommonNFTInput.parse(m)), {\n      onProgress: options?.onProgress,\n      rewriteFileNames: {\n        fileStartNumber: startFileNumber.toNumber()\n      }\n    });\n    const baseUri = getBaseUriFromBatch(uris);\n    const baseUriId = await this.contractWrapper.read(\"getBaseURICount\", []);\n    const hashedPassword = await this.hashDelayRevealPassword(baseUriId, password);\n    const encryptedBaseUri = await this.contractWrapper.read(\"encryptDecrypt\", [utils.toUtf8Bytes(baseUri), hashedPassword]);\n    let data;\n    const legacyContract = await this.isLegacyContract();\n    if (legacyContract) {\n      data = encryptedBaseUri;\n    } else {\n      const chainId = await this.contractWrapper.getChainID();\n      const provenanceHash = utils.solidityKeccak256([\"bytes\", \"bytes\", \"uint256\"], [utils.toUtf8Bytes(baseUri), hashedPassword, chainId]);\n      data = utils.defaultAbiCoder.encode([\"bytes\", \"bytes32\"], [encryptedBaseUri, provenanceHash]);\n    }\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"lazyMint\",\n      args: [uris.length, placeholderUri.endsWith(\"/\") ? placeholderUri : `${placeholderUri}/`, data],\n      parse: receipt => {\n        const events = this.contractWrapper.parseLogs(\"TokensLazyMinted\", receipt?.logs);\n        const startingIndex = events[0].args.startTokenId;\n        const endingIndex = events[0].args.endTokenId;\n        const results = [];\n        for (let id = startingIndex; id.lte(endingIndex); id = id.add(1)) {\n          results.push({\n            id,\n            receipt\n          });\n        }\n        return results;\n      }\n    });\n  });\n\n  /**\n   * Reveal a batch of hidden NFTs\n   * @remarks Reveal the NFTs of a batch using the password.\n   * @example\n   * ```javascript\n   * // the batch to reveal\n   * const batchId = 0;\n   * // reveal the batch\n   * await contract.revealer.reveal(batchId, \"my secret password\");\n   * ```\n   * @public\n   * @param batchId - the id of the batch to reveal\n   * @param password - the password\n   */\n  reveal = /* @__PURE__ */buildTransactionFunction(async (batchId, password) => {\n    if (!password) {\n      throw new Error(\"Password is required\");\n    }\n    const key = await this.hashDelayRevealPassword(batchId, password);\n    // performing the reveal locally to make sure it'd succeed before sending the transaction\n    try {\n      const decryptedUri = await this.contractWrapper.callStatic().reveal(batchId, key);\n      // basic sanity check for making sure decryptedUri is valid\n      // this is optional because invalid decryption key would result in non-utf8 bytes and\n      // ethers would throw when trying to decode it\n      if (!decryptedUri.includes(\"://\") || !decryptedUri.endsWith(\"/\")) {\n        throw new Error(\"invalid password\");\n      }\n    } catch (e) {\n      throw new Error(\"invalid password\");\n    }\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"reveal\",\n      args: [batchId, key]\n    });\n  });\n\n  /**\n   * Gets the list of unrevealed NFT batches.\n   * @remarks Gets the list of unrevealed NFT batches.\n   * @example\n   * ```javascript\n   * const batches = await contract.revealer.getBatchesToReveal();\n   * ```\n   * @public\n   */\n  async getBatchesToReveal() {\n    const count = await this.contractWrapper.read(\"getBaseURICount\", []);\n    if (count.isZero()) {\n      return [];\n    }\n    const countRangeArray = Array.from(Array(count.toNumber()).keys());\n    // map over to get the base uri indices, which should be the end token id of every batch\n    const uriIndices = await Promise.all(countRangeArray.map(i => {\n      if (hasFunction(\"getBatchIdAtIndex\", this.contractWrapper)) {\n        return this.contractWrapper.read(\"getBatchIdAtIndex\", [i]);\n      }\n      if (hasFunction(\"baseURIIndices\", this.contractWrapper)) {\n        return this.contractWrapper.read(\"baseURIIndices\", [i]);\n      }\n      throw new Error(\"Contract does not have getBatchIdAtIndex or baseURIIndices.\");\n    }));\n\n    // first batch always start from 0. don't need to fetch the last batch so pop it from the range array\n    const uriIndicesWithZeroStart = uriIndices.slice(0, uriIndices.length - 1);\n\n    // returns the token uri for each batches. first batch always starts from token id 0.\n    const tokenMetadatas = await Promise.all(Array.from([0, ...uriIndicesWithZeroStart]).map(i => this.getNftMetadata(i.toString())));\n\n    // index is the uri indices, which is end token id. different from uris\n    const legacyContract = await this.isLegacyContract();\n    const encryptedUriData = await Promise.all(Array.from([...uriIndices]).map(i => legacyContract ? this.getLegacyEncryptedData(i) : this.contractWrapper.read(\"encryptedData\", [i])));\n    const encryptedBaseUris = encryptedUriData.map(data => {\n      if (utils.hexDataLength(data) > 0) {\n        if (legacyContract) {\n          return data;\n        }\n        const result = utils.defaultAbiCoder.decode([\"bytes\", \"bytes32\"], data);\n        return result[0];\n      } else {\n        return data;\n      }\n    });\n    return tokenMetadatas.map((meta, index) => ({\n      batchId: BigNumber.from(index),\n      batchUri: meta.uri,\n      placeholderMetadata: meta\n    })).filter((_, index) => utils.hexDataLength(encryptedBaseUris[index]) > 0);\n  }\n\n  /**\n   * Algorithm to hash delay reveal password, so we don't broadcast the input password on-chain.\n   *\n   * @internal\n   */\n  async hashDelayRevealPassword(batchTokenIndex, password) {\n    const chainId = await this.contractWrapper.getChainID();\n    const contractAddress = this.contractWrapper.address;\n    return utils.solidityKeccak256([\"string\", \"uint256\", \"uint256\", \"address\"], [password, chainId, batchTokenIndex, contractAddress]);\n  }\n  async getNftMetadata(tokenId) {\n    return fetchTokenMetadataForContract(this.contractWrapper.address, this.contractWrapper.getProvider(), tokenId, this.storage);\n  }\n  async isLegacyContract() {\n    if (hasFunction(\"contractVersion\", this.contractWrapper)) {\n      try {\n        const version = await this.contractWrapper.read(\"contractVersion\", []);\n        return version <= 2;\n      } catch (e) {\n        return false;\n      }\n    }\n    return false;\n  }\n  async getLegacyEncryptedData(index) {\n    const DeprecatedAbi = (await import('@thirdweb-dev/contracts-js/dist/abis/IDelayedRevealDeprecated.json')).default;\n    const legacy = new Contract(this.contractWrapper.address, DeprecatedAbi, this.contractWrapper.getProvider());\n    const result = await legacy.functions[\"encryptedBaseURI\"](index);\n    if (result.length > 0) {\n      return result[0];\n    } else {\n      return \"0x\";\n    }\n  }\n}\n\nasync function calculateClaimCost(contractWrapper, pricePerToken, quantity, currencyAddress, checkERC20Allowance) {\n  let overrides = {};\n  const currency = currencyAddress || NATIVE_TOKEN_ADDRESS;\n  const normalizedPrice = await normalizePriceValue(contractWrapper.getProvider(), pricePerToken, currency);\n  const totalCost = normalizedPrice.mul(quantity);\n  if (totalCost.gt(0)) {\n    if (currency === NATIVE_TOKEN_ADDRESS) {\n      overrides = {\n        value: totalCost\n      };\n    } else if (currency !== NATIVE_TOKEN_ADDRESS && checkERC20Allowance) {\n      await approveErc20Allowance(contractWrapper, currency, totalCost, quantity, 0);\n    }\n  }\n  return overrides;\n}\n\n/**\n * Encodes and decodes Contract functions\n * @public\n */\nclass ContractOwner {\n  featureName = FEATURE_OWNER.name;\n  constructor(contractWrapper) {\n    this.contractWrapper = contractWrapper;\n  }\n\n  /**\n   * Get the current owner of the contract\n   * @example\n   * ```javascript\n   * await contract.owner.get();\n   * console.log(\"Owner address: \", ownerAddress);\n   * ```\n   * @returns The owner address\n   * @twfeature Ownable\n   */\n  async get() {\n    return this.contractWrapper.read(\"owner\", []);\n  }\n\n  /**\n   * Set the new owner of the contract\n   * @remarks Can only be called by the current owner.\n   *\n   * @param address - the address of the new owner\n   *\n   * @example\n   * ```javascript\n   * const newOwnerAddress = \"{{wallet_address}}\";\n   * await contract.owner.set(newOwnerAddress);\n   * ```\n   * @twfeature Ownable\n   */\n  set = /* @__PURE__ */buildTransactionFunction(async address => {\n    const resolvedAddress = await resolveAddress(address);\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"setOwner\",\n      args: [resolvedAddress]\n    });\n  });\n}\n\nexport { ContractRoyalty as C, DelayedReveal as D, ContractOwner as a, calculateClaimCost as c };\n"],"names":["InterfaceId_IERC721","utils","InterfaceId_IERC1155","FALLBACK_METADATA","name","async","fetchTokenMetadata","tokenId","tokenUri","storage","startsWith","Buffer","base64","split","jsonMetadata","JSON","parse","from","toString","CommonNFTOutput","id","BigNumber","uri","parsedUri","replace","toHexString","slice","downloadJSON","err","unparsedTokenIdUri","e","console","warn","concat","stringify","fetchTokenMetadataForContract","contractAddress","provider","ERC165MetadataAbi","default","erc165","Contract","isERC721","isERC1155","Promise","all","supportsInterface","ERC721MetadataAbi","erc721","tokenURI","Error","ERC1155MetadataAbi","erc1155","uploadOrExtractURI","metadata","upload","CommonNFTInput","uploadOrExtractURIs","metadatas","startNumber","options","undefined","find","m","isUriList","isMetadataList","uploadBatch","map","rewriteFileNames","fileStartNumber","onProgress","getBaseUriFromBatch","uris","baseUri","substring","lastIndexOf","i","length","DEFAULT_QUERY_ALL_COUNT","ContractRoyalty","constructor","contractWrapper","_defineProperty","FEATURE_ROYALTY","buildTransactionFunction","oldMetadata","this","get","mergedMetadata","parseInputMetadata","royaltyData","contractURI","_parseAndUploadMetadata","hasFunction","contractEncoder","ContractEncoder","encoded","encode","fee_recipient","seller_fee_basis_points","Transaction","fromContractWrapper","method","args","receipt","data","getDefaultRoyaltyInfo","parsedRoyaltyData","CommonRoyaltySchema","royaltyRecipient","royaltyBps","read","parseAsync","getTokenRoyaltyInfo","DelayedReveal","featureName","nextTokenIdToMintFn","placeholder","password","placeholderUris","placeholderUri","startFileNumber","toNumber","baseUriId","hashedPassword","hashDelayRevealPassword","encryptedBaseUri","isLegacyContract","chainId","getChainID","provenanceHash","endsWith","events","parseLogs","logs","startingIndex","startTokenId","endingIndex","endTokenId","results","lte","add","push","batchId","key","decryptedUri","callStatic","reveal","includes","getBatchesToReveal","count","isZero","countRangeArray","Array","keys","uriIndices","uriIndicesWithZeroStart","tokenMetadatas","getNftMetadata","legacyContract","encryptedBaseUris","getLegacyEncryptedData","decode","meta","index","batchUri","placeholderMetadata","filter","_","batchTokenIndex","address","getProvider","DeprecatedAbi","legacy","result","functions","calculateClaimCost","pricePerToken","quantity","currencyAddress","checkERC20Allowance","overrides","currency","NATIVE_TOKEN_ADDRESS","totalCost","normalizePriceValue","mul","gt","value","approveErc20Allowance","ContractOwner","FEATURE_OWNER","resolvedAddress","resolveAddress"],"sourceRoot":""}