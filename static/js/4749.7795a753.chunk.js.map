{"version":3,"file":"static/js/4749.7795a753.chunk.js","mappings":"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","sources":["../node_modules/@thirdweb-dev/sdk/dist/drop-claim-conditions-03410598.browser.esm.js"],"sourcesContent":["import { utils, BigNumber, constants } from 'ethers';\nimport deepEqual from 'fast-deep-equal';\nimport { aL as resolveAddress, cv as AmountSchema, B as includesErrorMessage, d4 as isNode, cq as ContractWrapper } from './index-c67c8d87.browser.esm.js';\nimport { y as transformResultToClaimCondition, z as legacyContractModelToAbstract, A as newContractModelToAbstract, C as ClaimEligibility, D as convertQuantityToBigNumber, f as fetchSnapshotEntryForAddress, E as prepareClaim, F as SnapshotFormatVersion, H as processClaimConditionInputs, I as abstractContractModelToLegacy, J as abstractContractModelToNew, K as updateExistingClaimConditions } from './signature-74888765.browser.esm.js';\nimport { i as isNativeToken, C as ContractEncoder } from './fetchCurrencyValue-ca929de6.browser.esm.js';\nimport { d as detectContractFeature, h as hasFunction } from './contract-appuri-8a73f5ec.browser.esm.js';\nimport { d as buildTransactionFunction, T as Transaction } from './transactions-d1b63e67.browser.esm.js';\n\n/**\n * Manages claim conditions for NFT Drop contracts\n * @public\n */\nclass DropClaimConditions {\n  constructor(contractWrapper, metadata, storage) {\n    this.storage = storage;\n    this.contractWrapper = contractWrapper;\n    this.metadata = metadata;\n  }\n\n  /** ***************************************\n   * READ FUNCTIONS\n   *****************************************/\n\n  /**\n   * Get the currently active claim condition\n   *\n   * @returns The claim condition metadata\n   */\n  async getActive(options) {\n    const [cc, metadata, tokenDecimals] = await Promise.all([this.get(), this.metadata.get(), this.getTokenDecimals()]);\n    return await transformResultToClaimCondition(cc, tokenDecimals, this.contractWrapper.getProvider(), metadata.merkle || {}, this.storage, options?.withAllowList || false);\n  }\n  async get(conditionId) {\n    if (this.isLegacySinglePhaseDrop(this.contractWrapper)) {\n      const contractModel = await this.contractWrapper.read(\"claimCondition\", []);\n      return legacyContractModelToAbstract(contractModel);\n    } else if (this.isLegacyMultiPhaseDrop(this.contractWrapper)) {\n      const id = conditionId !== undefined ? conditionId : await this.contractWrapper.read(\"getActiveClaimConditionId\", []);\n      const contractModel = await this.contractWrapper.read(\"getClaimConditionById\", [id]);\n      return legacyContractModelToAbstract(contractModel);\n    } else if (this.isNewSinglePhaseDrop(this.contractWrapper)) {\n      const contractModel = await this.contractWrapper.read(\"claimCondition\", []);\n      return newContractModelToAbstract(contractModel);\n    } else if (this.isNewMultiphaseDrop(this.contractWrapper)) {\n      const id = conditionId !== undefined ? conditionId : await this.contractWrapper.read(\"getActiveClaimConditionId\", []);\n      const contractModel = await this.contractWrapper.read(\"getClaimConditionById\", [id]);\n      return newContractModelToAbstract(contractModel);\n    } else {\n      throw new Error(\"Contract does not support claim conditions\");\n    }\n  }\n\n  /**\n   * Get all the claim conditions\n   *\n   * @returns The claim conditions metadata\n   */\n  async getAll(options) {\n    if (this.isLegacyMultiPhaseDrop(this.contractWrapper) || this.isNewMultiphaseDrop(this.contractWrapper)) {\n      const [currentStartId, countBn] = await this.contractWrapper.read(\"claimCondition\", []);\n      const startId = currentStartId.toNumber();\n      const count = countBn.toNumber();\n      const conditions = [];\n      for (let i = startId; i < startId + count; i++) {\n        conditions.push(this.get(i));\n      }\n      const [metadata, decimals, ...fetchedConditions] = await Promise.all([this.metadata.get(), this.getTokenDecimals(), ...conditions]);\n      return Promise.all(fetchedConditions.map(c => transformResultToClaimCondition(c, decimals, this.contractWrapper.getProvider(), metadata.merkle, this.storage, options?.withAllowList || false)));\n    } else {\n      return [await this.getActive(options)];\n    }\n  }\n\n  /**\n   * Can Claim\n   *\n   * @remarks Check if the drop can currently be claimed.\n   *\n   * @example\n   * ```javascript\n   * // Quantity of tokens to check claimability of\n   * const quantity = 1;\n   * const canClaim = await contract.canClaim(quantity);\n   * ```\n   */\n  async canClaim(quantity, addressToCheck) {\n    // TODO switch to use verifyClaim\n    if (addressToCheck) {\n      addressToCheck = await resolveAddress(addressToCheck);\n    }\n    return (await this.getClaimIneligibilityReasons(quantity, addressToCheck)).length === 0;\n  }\n\n  /**\n   * For any claim conditions that a particular wallet is violating,\n   * this function returns human readable information about the\n   * breaks in the condition that can be used to inform the user.\n   *\n   * @param quantity - The desired quantity that would be claimed.\n   * @param addressToCheck - The wallet address, defaults to the connected wallet.\n   *\n   */\n  async getClaimIneligibilityReasons(quantity, addressToCheck) {\n    const reasons = [];\n    let activeConditionIndex;\n    let claimCondition;\n    if (addressToCheck === undefined) {\n      try {\n        addressToCheck = await this.contractWrapper.getSignerAddress();\n      } catch (err) {\n        console.warn(\"failed to get signer address\", err);\n      }\n    }\n\n    // if we have been unable to get a signer address, we can't check eligibility, so return a NoWallet error reason\n    if (!addressToCheck) {\n      return [ClaimEligibility.NoWallet];\n    }\n    const [resolvedAddress, decimals] = await Promise.all([resolveAddress(addressToCheck), this.getTokenDecimals()]);\n    const quantityWithDecimals = utils.parseUnits(AmountSchema.parse(quantity), decimals);\n    try {\n      claimCondition = await this.getActive();\n    } catch (err) {\n      if (includesErrorMessage(err, \"!CONDITION\") || includesErrorMessage(err, \"no active mint condition\")) {\n        reasons.push(ClaimEligibility.NoClaimConditionSet);\n        return reasons;\n      }\n      console.warn(\"failed to get active claim condition\", err);\n      reasons.push(ClaimEligibility.Unknown);\n      return reasons;\n    }\n    if (claimCondition.availableSupply !== \"unlimited\") {\n      const supplyWithDecimals = utils.parseUnits(claimCondition.availableSupply, decimals);\n      if (supplyWithDecimals.lt(quantityWithDecimals)) {\n        reasons.push(ClaimEligibility.NotEnoughSupply);\n        return reasons;\n      }\n    }\n\n    // check for merkle root inclusion\n    const merkleRootArray = utils.stripZeros(claimCondition.merkleRootHash);\n    const hasAllowList = merkleRootArray.length > 0;\n    let allowListEntry = null;\n    if (hasAllowList) {\n      allowListEntry = await this.getClaimerProofs(resolvedAddress);\n      if (!allowListEntry && (this.isLegacySinglePhaseDrop(this.contractWrapper) || this.isLegacyMultiPhaseDrop(this.contractWrapper))) {\n        // exclusive allowlist behavior\n        reasons.push(ClaimEligibility.AddressNotAllowed);\n        return reasons;\n      }\n      if (allowListEntry) {\n        try {\n          const claimVerification = await this.prepareClaim(quantity, false, decimals, resolvedAddress);\n          let validMerkleProof;\n          if (this.isLegacyMultiPhaseDrop(this.contractWrapper)) {\n            activeConditionIndex = await this.contractWrapper.read(\"getActiveClaimConditionId\", []);\n            // legacy verifyClaimerMerkleProofs function\n            [validMerkleProof] = await this.contractWrapper.read(\"verifyClaimMerkleProof\", [activeConditionIndex, resolvedAddress, quantity, claimVerification.proofs, claimVerification.maxClaimable]);\n            if (!validMerkleProof) {\n              reasons.push(ClaimEligibility.AddressNotAllowed);\n              return reasons;\n            }\n          } else if (this.isLegacySinglePhaseDrop(this.contractWrapper)) {\n            [validMerkleProof] = await this.contractWrapper.read(\"verifyClaimMerkleProof\", [resolvedAddress, quantity, {\n              proof: claimVerification.proofs,\n              maxQuantityInAllowlist: claimVerification.maxClaimable\n            }]);\n            if (!validMerkleProof) {\n              reasons.push(ClaimEligibility.AddressNotAllowed);\n              return reasons;\n            }\n          } else if (this.isNewSinglePhaseDrop(this.contractWrapper)) {\n            await this.contractWrapper.read(\"verifyClaim\", [resolvedAddress, quantity, claimVerification.currencyAddress, claimVerification.price, {\n              proof: claimVerification.proofs,\n              quantityLimitPerWallet: claimVerification.maxClaimable,\n              currency: claimVerification.currencyAddressInProof,\n              pricePerToken: claimVerification.priceInProof\n            }]);\n          } else if (this.isNewMultiphaseDrop(this.contractWrapper)) {\n            activeConditionIndex = await this.contractWrapper.read(\"getActiveClaimConditionId\", []);\n            await this.contractWrapper.read(\"verifyClaim\", [activeConditionIndex, resolvedAddress, quantity, claimVerification.currencyAddress, claimVerification.price, {\n              proof: claimVerification.proofs,\n              quantityLimitPerWallet: claimVerification.maxClaimable,\n              currency: claimVerification.currencyAddressInProof,\n              pricePerToken: claimVerification.priceInProof\n            }]);\n          }\n        } catch (e) {\n          console.warn(\"Merkle proof verification failed:\", \"reason\" in e ? e.reason : e);\n          const reason = e.reason;\n          switch (reason) {\n            case \"!Qty\":\n              reasons.push(ClaimEligibility.OverMaxClaimablePerWallet);\n              break;\n            case \"!PriceOrCurrency\":\n              reasons.push(ClaimEligibility.WrongPriceOrCurrency);\n              break;\n            case \"!MaxSupply\":\n              reasons.push(ClaimEligibility.NotEnoughSupply);\n              break;\n            case \"cant claim yet\":\n              reasons.push(ClaimEligibility.ClaimPhaseNotStarted);\n              break;\n            default:\n              {\n                reasons.push(ClaimEligibility.AddressNotAllowed);\n                break;\n              }\n          }\n          return reasons;\n        }\n      }\n    }\n    if (this.isNewSinglePhaseDrop(this.contractWrapper) || this.isNewMultiphaseDrop(this.contractWrapper)) {\n      let claimedSupply = BigNumber.from(0);\n      let maxClaimable = convertQuantityToBigNumber(claimCondition.maxClaimablePerWallet, decimals);\n      try {\n        claimedSupply = await this.getSupplyClaimedByWallet(resolvedAddress);\n      } catch (e) {\n        // no-op\n      }\n      if (allowListEntry) {\n        maxClaimable = convertQuantityToBigNumber(allowListEntry.maxClaimable, decimals);\n      }\n      if (maxClaimable.gt(0) && maxClaimable.lt(claimedSupply.add(quantityWithDecimals))) {\n        reasons.push(ClaimEligibility.OverMaxClaimablePerWallet);\n        return reasons;\n      }\n\n      // if there is no allowlist, or if there is an allowlist and the address is not in it\n      // if maxClaimable is 0, we consider it as the address is not allowed\n      if (!hasAllowList || hasAllowList && !allowListEntry) {\n        if (maxClaimable.lte(claimedSupply) || maxClaimable.eq(0)) {\n          reasons.push(ClaimEligibility.AddressNotAllowed);\n          return reasons;\n        }\n      }\n    }\n\n    // check for claim timestamp between claims (ONLY FOR LEGACY)\n    if (this.isLegacySinglePhaseDrop(this.contractWrapper) || this.isLegacyMultiPhaseDrop(this.contractWrapper)) {\n      let [lastClaimedTimestamp, timestampForNextClaim] = [BigNumber.from(0), BigNumber.from(0)];\n      if (this.isLegacyMultiPhaseDrop(this.contractWrapper)) {\n        activeConditionIndex = await this.contractWrapper.read(\"getActiveClaimConditionId\", []);\n        [lastClaimedTimestamp, timestampForNextClaim] = await this.contractWrapper.read(\"getClaimTimestamp\", [activeConditionIndex, resolvedAddress]);\n      } else if (this.isLegacySinglePhaseDrop(this.contractWrapper)) {\n        // check for claim timestamp between claims\n        [lastClaimedTimestamp, timestampForNextClaim] = await this.contractWrapper.read(\"getClaimTimestamp\", [resolvedAddress]);\n      }\n      const now = BigNumber.from(Date.now()).div(1000);\n      if (lastClaimedTimestamp.gt(0) && now.lt(timestampForNextClaim)) {\n        // contract will return MaxUint256 if user has already claimed and cannot claim again\n        if (timestampForNextClaim.eq(constants.MaxUint256)) {\n          reasons.push(ClaimEligibility.AlreadyClaimed);\n        } else {\n          reasons.push(ClaimEligibility.WaitBeforeNextClaimTransaction);\n        }\n        return reasons;\n      }\n    }\n\n    // if not within a browser context, check for wallet balance.\n    // In browser context, let the wallet do that job\n    if (claimCondition.price.gt(0) && isNode()) {\n      const totalPrice = claimCondition.price.mul(BigNumber.from(quantity));\n      const provider = this.contractWrapper.getProvider();\n      if (isNativeToken(claimCondition.currencyAddress)) {\n        const balance = await provider.getBalance(resolvedAddress);\n        if (balance.lt(totalPrice)) {\n          reasons.push(ClaimEligibility.NotEnoughTokens);\n        }\n      } else {\n        const ERC20Abi = (await import('@thirdweb-dev/contracts-js/dist/abis/IERC20.json')).default;\n        const erc20 = new ContractWrapper(provider, claimCondition.currencyAddress, ERC20Abi, {}, this.storage);\n        const balance = await erc20.read(\"balanceOf\", [resolvedAddress]);\n        if (balance.lt(totalPrice)) {\n          reasons.push(ClaimEligibility.NotEnoughTokens);\n        }\n      }\n    }\n    return reasons;\n  }\n\n  /**\n   * Returns allow list information and merkle proofs for the given address.\n   * @param claimerAddress - the claimer address\n   * @param claimConditionId - optional the claim condition id to get the proofs for\n   */\n  async getClaimerProofs(claimerAddress, claimConditionId) {\n    const claimCondition = await this.get(claimConditionId);\n    const merkleRoot = claimCondition.merkleRoot;\n    const merkleRootArray = utils.stripZeros(merkleRoot);\n    if (merkleRootArray.length > 0) {\n      const [metadata, resolvedAddress] = await Promise.all([this.metadata.get(), resolveAddress(claimerAddress)]);\n      return await fetchSnapshotEntryForAddress(resolvedAddress, merkleRoot.toString(), metadata.merkle, this.contractWrapper.getProvider(), this.storage, this.getSnapshotFormatVersion());\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * Get the total supply claimed by a specific wallet\n   * @param walletAddress - the wallet address to check\n   * @returns The total supply claimed\n   */\n  async getSupplyClaimedByWallet(walletAddress) {\n    const resolvedAddress = await resolveAddress(walletAddress);\n    if (this.isNewSinglePhaseDrop(this.contractWrapper)) {\n      return await this.contractWrapper.read(\"getSupplyClaimedByWallet\", [resolvedAddress]);\n    }\n    if (this.isNewMultiphaseDrop(this.contractWrapper)) {\n      const activeClaimConditionId = await this.contractWrapper.read(\"getActiveClaimConditionId\", []);\n      return await this.contractWrapper.read(\"getSupplyClaimedByWallet\", [activeClaimConditionId, resolvedAddress]);\n    }\n    throw new Error(\"This contract does not support the getSupplyClaimedByWallet function\");\n  }\n\n  /** ***************************************\n   * WRITE FUNCTIONS\n   *****************************************/\n\n  /**\n   * Set public mint conditions\n   *\n   * @remarks Sets the public mint conditions that need to be fullfiled by users to claim NFTs.\n   *\n   * @example\n   * ```javascript\n   * const presaleStartTime = new Date();\n   * const publicSaleStartTime = new Date(Date.now() + 60 * 60 * 24 * 1000);\n   *\n   * // Optionally specify addresses that can claim\n   * const snapshots = ['0x...', '0x...']\n   *\n   * // Or alternatively, you can pass snapshots with the max number of NFTs each address can claim\n   * // const snapshots = [{ address: '0x...', maxClaimable: 1 }, { address: '0x...', maxClaimable: 2 }]\n   *\n   * const claimConditions = [\n   *   {\n   *     startTime: presaleStartTime, // start the presale now\n   *     maxClaimableSupply: 2, // limit how many mints for this presale\n   *     price: 0.01, // presale price\n   *     snapshot: snapshots, // limit minting to only certain addresses\n   *   },\n   *   {\n   *     startTime: publicSaleStartTime, // 24h after presale, start public sale\n   *     price: 0.08, // public sale price\n   *   }\n   * ]);\n   *\n   * await dropContract.claimConditions.set(claimConditions);\n   * ```\n   *\n   * @param claimConditionInputs - The claim conditions\n   * @param resetClaimEligibilityForAll - Whether to reset the state of who already claimed NFTs previously\n   */\n  set = /* @__PURE__ */buildTransactionFunction((() => {\n    var _this = this;\n    return async function (claimConditionInputs) {\n      let resetClaimEligibilityForAll = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      let claimConditionsProcessed = claimConditionInputs;\n      if (_this.isLegacySinglePhaseDrop(_this.contractWrapper) || _this.isNewSinglePhaseDrop(_this.contractWrapper)) {\n        resetClaimEligibilityForAll = true;\n        if (claimConditionInputs.length === 0) {\n          claimConditionsProcessed = [{\n            startTime: new Date(0),\n            currencyAddress: constants.AddressZero,\n            price: 0,\n            maxClaimableSupply: 0,\n            maxClaimablePerWallet: 0,\n            waitInSeconds: 0,\n            merkleRootHash: utils.hexZeroPad([0], 32),\n            snapshot: []\n          }];\n        } else if (claimConditionInputs.length > 1) {\n          throw new Error(\"Single phase drop contract cannot have multiple claim conditions, only one is allowed\");\n        }\n      }\n\n      // if using new snapshot format, make sure that maxClaimablePerWallet is set if allowlist is set as well\n      if (_this.isNewSinglePhaseDrop(_this.contractWrapper) || _this.isNewMultiphaseDrop(_this.contractWrapper)) {\n        claimConditionsProcessed.forEach(cc => {\n          if (cc.snapshot && cc.snapshot.length > 0 && (cc.maxClaimablePerWallet === undefined || cc.maxClaimablePerWallet === \"unlimited\")) {\n            throw new Error(\"maxClaimablePerWallet must be set to a specific value when an allowlist is set.\\n\" + \"Example: Set it to 0 to only allow addresses in the allowlist to claim the amount specified in the allowlist.\\n\" + \"contract.claimConditions.set([{ snapshot: [{ address: '0x...', maxClaimable: 1 }], maxClaimablePerWallet: 0 }])\");\n          }\n          if (cc.snapshot && cc.snapshot.length > 0 && cc.maxClaimablePerWallet?.toString() === \"0\" && cc.snapshot.map(s => {\n            if (typeof s === \"string\") {\n              return 0;\n            } else {\n              return Number(s.maxClaimable?.toString() || 0);\n            }\n          }).reduce((acc, current) => {\n            return acc + current;\n          }, 0) === 0) {\n            throw new Error(\"maxClaimablePerWallet is set to 0, and all addresses in the allowlist have max claimable 0. This means that no one can claim.\");\n          }\n        });\n      }\n\n      // process inputs\n      const {\n        snapshotInfos,\n        sortedConditions\n      } = await processClaimConditionInputs(claimConditionsProcessed, await _this.getTokenDecimals(), _this.contractWrapper.getProvider(), _this.storage, _this.getSnapshotFormatVersion());\n      const merkleInfo = {};\n      snapshotInfos.forEach(s => {\n        merkleInfo[s.merkleRoot] = s.snapshotUri;\n      });\n      const metadata = await _this.metadata.get();\n      const encoded = [];\n\n      // upload new merkle roots to snapshot URIs if updated\n      if (!deepEqual(metadata.merkle, merkleInfo)) {\n        const mergedMetadata = await _this.metadata.parseInputMetadata({\n          ...metadata,\n          merkle: merkleInfo\n        });\n        // using internal method to just upload, avoids one contract call\n        const contractURI = await _this.metadata._parseAndUploadMetadata(mergedMetadata);\n\n        // TODO (cc) we could write the merkle tree info on the claim condition metadata instead\n        // TODO (cc) but we still need to maintain the behavior here for older contracts\n        if (hasFunction(\"setContractURI\", _this.contractWrapper)) {\n          const contractEncoder = new ContractEncoder(_this.contractWrapper);\n          encoded.push(contractEncoder.encode(\"setContractURI\", [contractURI]));\n        } else {\n          throw new Error(\"Setting a merkle root requires implementing ContractMetadata in your contract to support storing a merkle root.\");\n        }\n      }\n      const cw = _this.contractWrapper;\n      const baseContractEncoder = new ContractEncoder(cw);\n      if (_this.isLegacySinglePhaseDrop(cw)) {\n        const contractEncoderLegacy = new ContractEncoder(cw);\n        encoded.push(contractEncoderLegacy.encode(\"setClaimConditions\", [abstractContractModelToLegacy(sortedConditions[0]), resetClaimEligibilityForAll]));\n      } else if (_this.isLegacyMultiPhaseDrop(cw)) {\n        encoded.push(baseContractEncoder.encode(\"setClaimConditions\", [sortedConditions.map(abstractContractModelToLegacy), resetClaimEligibilityForAll]));\n      } else if (_this.isNewSinglePhaseDrop(cw)) {\n        encoded.push(baseContractEncoder.encode(\"setClaimConditions\", [abstractContractModelToNew(sortedConditions[0]), resetClaimEligibilityForAll]));\n      } else if (_this.isNewMultiphaseDrop(cw)) {\n        encoded.push(baseContractEncoder.encode(\"setClaimConditions\", [sortedConditions.map(abstractContractModelToNew), resetClaimEligibilityForAll]));\n      } else {\n        throw new Error(\"Contract does not support claim conditions\");\n      }\n      if (hasFunction(\"multicall\", _this.contractWrapper)) {\n        return Transaction.fromContractWrapper({\n          contractWrapper: _this.contractWrapper,\n          method: \"multicall\",\n          args: [encoded]\n        });\n      }\n      throw new Error(\"Contract does not support multicall\");\n    };\n  })());\n\n  /**\n   * Update a single claim condition with new data.\n   *\n   * @param index - the index of the claim condition to update, as given by the index from the result of `getAll()`\n   * @param claimConditionInput - the new data to update, previous data will be retained\n   */\n  update = /* @__PURE__ */buildTransactionFunction(async (index, claimConditionInput) => {\n    const existingConditions = await this.getAll();\n    const newConditionInputs = await updateExistingClaimConditions(index, claimConditionInput, existingConditions);\n    return await this.set.prepare(newConditionInputs);\n  });\n\n  /** ***************************************\n   * PRIVATE FUNCTIONS\n   *****************************************/\n\n  async getTokenDecimals() {\n    if (detectContractFeature(this.contractWrapper, \"ERC20\")) {\n      return this.contractWrapper.read(\"decimals\", []);\n    } else {\n      return Promise.resolve(0);\n    }\n  }\n\n  /**\n   * Returns proofs and the overrides required for the transaction.\n   *\n   * @returns  `overrides` and `proofs` as an object.\n   * @internal\n   */\n  async prepareClaim(quantity, checkERC20Allowance) {\n    let decimals = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    let address = arguments.length > 3 ? arguments[3] : undefined;\n    const [addressToClaim, activeClaimConditions] = await Promise.all([address ? address : this.contractWrapper.getSignerAddress(), this.getActive()]);\n    return prepareClaim(addressToClaim, quantity, activeClaimConditions, async () => (await this.metadata.get()).merkle, decimals, this.contractWrapper, this.storage, checkERC20Allowance, this.getSnapshotFormatVersion());\n  }\n  async getClaimArguments(destinationAddress, quantity, claimVerification) {\n    const resolvedAddress = await resolveAddress(destinationAddress);\n    if (this.isLegacyMultiPhaseDrop(this.contractWrapper)) {\n      return [resolvedAddress, quantity, claimVerification.currencyAddress, claimVerification.price, claimVerification.proofs, claimVerification.maxClaimable];\n    } else if (this.isLegacySinglePhaseDrop(this.contractWrapper)) {\n      return [resolvedAddress, quantity, claimVerification.currencyAddress, claimVerification.price, {\n        proof: claimVerification.proofs,\n        maxQuantityInAllowlist: claimVerification.maxClaimable\n      }, utils.toUtf8Bytes(\"\")];\n    }\n    return [resolvedAddress, quantity, claimVerification.currencyAddress, claimVerification.price, {\n      proof: claimVerification.proofs,\n      quantityLimitPerWallet: claimVerification.maxClaimable,\n      pricePerToken: claimVerification.priceInProof,\n      currency: claimVerification.currencyAddressInProof\n    }, utils.toUtf8Bytes(\"\")];\n  }\n\n  /**\n   * Construct a claim transaction without executing it.\n   * This is useful for estimating the gas cost of a claim transaction, overriding transaction options and having fine grained control over the transaction execution.\n   * @param destinationAddress - The address to claim to\n   * @param quantity - The quantity to claim\n   * @param options - Options to override the claim transaction\n   *\n   * @deprecated Use `contract.erc721.claim.prepare(...args)` instead\n   */\n  async getClaimTransaction(destinationAddress, quantity, options) {\n    // TODO: Transaction Sequence Pattern\n    if (options?.pricePerToken) {\n      throw new Error(\"Price per token is be set via claim conditions by calling `contract.erc721.claimConditions.set()`\");\n    }\n    const claimVerification = await this.prepareClaim(quantity, options?.checkERC20Allowance === undefined ? true : options.checkERC20Allowance, await this.getTokenDecimals());\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"claim\",\n      args: await this.getClaimArguments(destinationAddress, quantity, claimVerification),\n      overrides: claimVerification.overrides\n    });\n  }\n  isNewSinglePhaseDrop(contractWrapper) {\n    return detectContractFeature(contractWrapper, \"ERC721ClaimConditionsV2\") || detectContractFeature(contractWrapper, \"ERC20ClaimConditionsV2\");\n  }\n  isNewMultiphaseDrop(contractWrapper) {\n    return detectContractFeature(contractWrapper, \"ERC721ClaimPhasesV2\") || detectContractFeature(contractWrapper, \"ERC20ClaimPhasesV2\");\n  }\n  isLegacySinglePhaseDrop(contractWrapper) {\n    return detectContractFeature(contractWrapper, \"ERC721ClaimConditionsV1\") || detectContractFeature(contractWrapper, \"ERC20ClaimConditionsV1\");\n  }\n  isLegacyMultiPhaseDrop(contractWrapper) {\n    return detectContractFeature(contractWrapper, \"ERC721ClaimPhasesV1\") || detectContractFeature(contractWrapper, \"ERC20ClaimPhasesV1\");\n  }\n  getSnapshotFormatVersion() {\n    return this.isLegacyMultiPhaseDrop(this.contractWrapper) || this.isLegacySinglePhaseDrop(this.contractWrapper) ? SnapshotFormatVersion.V1 : SnapshotFormatVersion.V2;\n  }\n}\n\nexport { DropClaimConditions as D };\n"],"names":["DropClaimConditions","constructor","contractWrapper","metadata","storage","_defineProperty","buildTransactionFunction","_this","this","async","claimConditionInputs","resetClaimEligibilityForAll","arguments","length","undefined","claimConditionsProcessed","isLegacySinglePhaseDrop","isNewSinglePhaseDrop","startTime","Date","currencyAddress","constants","price","maxClaimableSupply","maxClaimablePerWallet","waitInSeconds","merkleRootHash","utils","snapshot","Error","isNewMultiphaseDrop","forEach","cc","_cc$maxClaimablePerWa","toString","map","s","Number","_s$maxClaimable","maxClaimable","reduce","acc","current","snapshotInfos","sortedConditions","processClaimConditionInputs","getTokenDecimals","getProvider","getSnapshotFormatVersion","merkleInfo","merkleRoot","snapshotUri","get","encoded","deepEqual","merkle","mergedMetadata","parseInputMetadata","contractURI","_parseAndUploadMetadata","hasFunction","contractEncoder","ContractEncoder","push","encode","cw","baseContractEncoder","contractEncoderLegacy","abstractContractModelToLegacy","isLegacyMultiPhaseDrop","abstractContractModelToNew","Transaction","fromContractWrapper","method","args","index","claimConditionInput","existingConditions","getAll","newConditionInputs","updateExistingClaimConditions","set","prepare","getActive","options","tokenDecimals","Promise","all","transformResultToClaimCondition","withAllowList","conditionId","contractModel","read","legacyContractModelToAbstract","id","newContractModelToAbstract","currentStartId","countBn","startId","toNumber","count","conditions","i","decimals","fetchedConditions","c","canClaim","quantity","addressToCheck","resolveAddress","getClaimIneligibilityReasons","reasons","activeConditionIndex","claimCondition","getSignerAddress","err","console","warn","ClaimEligibility","NoWallet","resolvedAddress","quantityWithDecimals","AmountSchema","parse","includesErrorMessage","NoClaimConditionSet","Unknown","availableSupply","lt","NotEnoughSupply","hasAllowList","allowListEntry","getClaimerProofs","AddressNotAllowed","claimVerification","prepareClaim","validMerkleProof","proofs","proof","maxQuantityInAllowlist","quantityLimitPerWallet","currency","currencyAddressInProof","pricePerToken","priceInProof","e","reason","OverMaxClaimablePerWallet","WrongPriceOrCurrency","ClaimPhaseNotStarted","claimedSupply","BigNumber","from","convertQuantityToBigNumber","getSupplyClaimedByWallet","gt","add","lte","eq","lastClaimedTimestamp","timestampForNextClaim","now","div","AlreadyClaimed","WaitBeforeNextClaimTransaction","isNode","totalPrice","mul","provider","isNativeToken","getBalance","NotEnoughTokens","ERC20Abi","default","erc20","ContractWrapper","claimerAddress","claimConditionId","fetchSnapshotEntryForAddress","walletAddress","activeClaimConditionId","detectContractFeature","resolve","checkERC20Allowance","address","addressToClaim","activeClaimConditions","getClaimArguments","destinationAddress","getClaimTransaction","overrides","SnapshotFormatVersion","V1","V2"],"sourceRoot":""}