{"version":3,"file":"static/js/6821.b8ef4823.chunk.js","mappings":"oNAWA,SAASA,EAAsBC,EAAiBC,GAE9C,OADUC,EAAAA,EAAAA,IAAmBF,EAAgBG,IAAKF,EAAaD,EAAgBI,WAEjF,CAOA,SAASC,EAAYC,EAAcN,GACjC,OAAOM,KAAgBN,EAAgBO,aAAaC,SACtD,CAoBA,MAAMC,EAEJC,WAAAA,CAAYV,EAAiBW,EAAQC,IAASC,EAAAA,EAAAA,GAAA,mBADhCC,EAAAA,GAAiBC,OA0E/BF,EAAAA,EAAAA,GAAA,YAcqBG,EAAAA,EAAAA,IAAyBC,UAC5C,MAAMC,QAAYC,KAAKC,wBAAwBC,GACzCC,EAAUH,KAAKnB,gBACrB,GAAImB,KAAKI,yBAAyBD,GAChC,OAAOE,EAAAA,EAAYC,oBAAoB,CACrCzB,gBAAiBmB,KAAKnB,gBACtB0B,OAAQ,iBACRC,KAAM,CAACT,GACPU,MAAOC,IACE,CACLA,UACAC,KAAMX,KAAKY,QAKjB,MAAM,IAAIC,EAAAA,EAA6BlB,EAAAA,GACzC,MAGFD,EAAAA,EAAAA,GAAA,eAawBG,EAAAA,EAAAA,IAAyBC,eAClCE,KAAKc,IAAIC,QAAQ,UAClBf,KAAKY,SACZV,OA1HLF,KAAKnB,gBAAkBA,EACvBmB,KAAKR,OAASA,EACdQ,KAAKP,QAAUA,CACjB,CAIAuB,mBAAAA,CAAoBd,GAClB,OAAOF,KAAKR,OAAOyB,OAAOC,WAAWhB,EACvC,CAKAiB,kBAAAA,CAAmBjB,GACjB,OAAOF,KAAKR,OAAO4B,MAAMF,WAAWhB,EACtC,CAaA,SAAMU,GACJ,IAAID,EACJ,GAAIX,KAAKI,yBAAyBJ,KAAKnB,iBAAkB,CACvD,MAAMkB,QAAYC,KAAKnB,gBAAgBwC,KAAK,cAAe,IACvDtB,GAAOA,EAAIuB,SAAS,SACtBX,QAAaX,KAAKP,QAAQ8B,aAAaxB,GAE3C,CACA,IAAKY,EACH,IAAI,IAAAa,EAAAC,EAEF,IAAIC,EAQAC,EAQAC,EAfJ,IACM1C,EAAY,OAAQc,KAAKnB,mBAC3B6C,QAAqB1B,KAAKnB,gBAAgBwC,KAAK,OAAQ,IAE3D,CAAE,MAAOQ,GACP,CAGF,IACM3C,EAAY,SAAUc,KAAKnB,mBAC7B8C,QAAuB3B,KAAKnB,gBAAgBwC,KAAK,SAAU,IAE/D,CAAE,MAAOQ,GACP,CAGF,IACED,QAA0BE,EAAAA,EAAAA,GAAiC9B,KAAKnB,gBAAgBkD,QAAS/B,KAAKnB,gBAAgBmD,cAAehC,KAAKP,QAASO,KAAKnB,gBAAgBoD,QAClK,CAAE,MAAOJ,GAAM,CACflB,EAAO,CACLf,KAAM8B,IAAiC,QAArBF,EAAII,SAAiB,IAAAJ,OAAA,EAAjBA,EAAmB5B,MACzCsC,OAAQP,EACRQ,YAA8B,QAAnBV,EAAEG,SAAiB,IAAAH,OAAA,EAAjBA,EAAmBW,KAAKC,MAEzC,CAAE,MAAOC,GACP,MAAM,IAAIC,MAAM,oCAClB,CAEF,OAAOvC,KAAKgB,oBAAoBL,EAClC,CA8DA,6BAAMV,CAAwBC,GAC5B,MAAMsC,QAAuBxC,KAAKmB,mBAAmBjB,GACrD,OAAOF,KAAKP,QAAQgD,OAAOD,EAC7B,CACApC,wBAAAA,CAAyBvB,GACvB,OAAOD,EAAsBC,EAAiB,mBAChD,EAOF,MAAM6D,EACJnD,WAAAA,CAAYV,GACVmB,KAAKnB,gBAAkBA,CACzB,CAcA8D,sBAAAA,CAAuBC,GACrB5C,KAAKnB,gBAAgBgE,YAAYC,EAAAA,GAAUzC,YAAauC,EAC1D,CAcAG,yBAAAA,CAA0BH,GACxB5C,KAAKnB,gBAAgBmE,IAAIF,EAAAA,GAAUzC,YAAauC,EAClD,CAkBAK,gBAAAA,CAEAC,EAAWN,GAET,MAAMO,EAAQnD,KAAKnB,gBAAgBO,aAAagE,UAAUC,SAASH,GAE7DI,EAAS,CACbvB,QAFc/B,KAAKnB,gBAAgBkD,QAGnCwB,OAAQ,CAACvD,KAAKnB,gBAAgBO,aAAagE,UAAUI,cAAcL,KAE/DM,EAAkBC,IACtB,MAAMC,EAAY3D,KAAKnB,gBAAgBO,aAAagE,UAAUQ,SAASF,GACvEd,EAAS5C,KAAK6D,gBAAgBF,EAAUG,cAAeH,EAAUnD,KAAMkD,GAAK,EAG9E,OADA1D,KAAKnB,gBAAgBmD,cAAc+B,GAAGT,EAAQG,GACvC,KACLzD,KAAKnB,gBAAgBmD,cAAcgB,IAAIM,EAAQG,EAAgB,CAEnE,CAgBAO,iBAAAA,CAAkBpB,GAChB,MACMU,EAAS,CACbvB,QAFc/B,KAAKnB,gBAAgBkD,SAI/B0B,EAAkBC,IACtB,IACE,MAAMC,EAAY3D,KAAKnB,gBAAgBO,aAAagE,UAAUQ,SAASF,GACvEd,EAAS5C,KAAK6D,gBAAgBF,EAAUG,cAAeH,EAAUnD,KAAMkD,GACzE,CAAE,MAAOpB,GACP2B,QAAQC,MAAM,yBAA0BR,EAAKpB,EAC/C,GAGF,OADAtC,KAAKnB,gBAAgBmD,cAAc+B,GAAGT,EAAQG,GACvC,KACLzD,KAAKnB,gBAAgBmD,cAAcgB,IAAIM,EAAQG,EAAgB,CAEnE,CAeAU,mBAAAA,CAEAjB,EAAWN,GAET,MAAMO,EAAQnD,KAAKnB,gBAAgBO,aAAagE,UAAUC,SAASH,GACnElD,KAAKnB,gBAAgBO,aAAa4D,IAAIG,EAAMvD,KAAMgD,EACpD,CAWAwB,kBAAAA,GACEpE,KAAKnB,gBAAgBO,aAAagF,qBAClC,MACMd,EAAS,CACbvB,QAFc/B,KAAKnB,gBAAgBkD,SAIrC/B,KAAKnB,gBAAgBmD,cAAcoC,mBAAmBd,EACxD,CAoBA,kBAAMe,GACJ,IAAIC,EAAUC,UAAUC,OAAS,QAAsBC,IAAjBF,UAAU,GAAmBA,UAAU,GAAK,CAChFG,UAAW,EACXC,QAAS,SACTC,MAAO,QAET,MACMC,SADe7E,KAAKnB,gBAAgBO,aAAa0F,YAAY,CAAC,EAAGR,EAAQI,UAAWJ,EAAQK,UACrEI,MAAK,CAACC,EAAGC,IACX,SAAlBX,EAAQM,MAAmBK,EAAEC,YAAcF,EAAEE,YAAcF,EAAEE,YAAcD,EAAEC,cAEtF,OAAOlF,KAAKmF,YAAYN,EAC1B,CA+BA,eAAMO,CAAUlC,GACd,IAAIjB,EAAUsC,UAAUC,OAAS,QAAsBC,IAAjBF,UAAU,GAAmBA,UAAU,GAAK,CAChFG,UAAW,EACXC,QAAS,SACTC,MAAO,QAET,MAAMS,EAAiBrF,KAAKnB,gBAAgBO,aAAagE,UAAUC,SAASH,GACtE1C,EAAOyB,EAAQqC,QAAUe,EAAeC,OAAOC,KAAIjD,GAAKL,EAAQqC,QAAQhC,EAAE1C,QAAS,GACnF0D,EAAStD,KAAKnB,gBAAgBO,aAAakF,QAAQe,EAAezF,SAASY,GAE3EqE,SADe7E,KAAKnB,gBAAgBO,aAAa0F,YAAYxB,EAAQrB,EAAQyC,UAAWzC,EAAQ0C,UACzEI,MAAK,CAACC,EAAGC,IACX,SAAlBhD,EAAQ2C,MAAmBK,EAAEC,YAAcF,EAAEE,YAAcF,EAAEE,YAAcD,EAAEC,cAEtF,OAAOlF,KAAKmF,YAAYN,EAC1B,CACAM,WAAAA,CAAYK,GACV,OAAOA,EAAOD,KAAIjD,IAChB,MAAMmD,EAAcC,OAAOC,YAAYD,OAAOE,QAAQtD,GAAGgB,QAAO0B,GAAqB,oBAATA,EAAE,IAA8B,SAATA,EAAE,MACrG,GAAI1C,EAAE9B,KAAM,CACV,MAAMoF,EAAUF,OAAOE,QAAQtD,EAAE9B,MAC3BA,EAAOoF,EAAQC,MAAMD,EAAQpB,OAAS,EAAGoB,EAAQpB,QACjD7D,EAAO,CAAC,EACd,IAAK,MAAOmF,EAAKC,KAAUvF,EACzBG,EAAKmF,GAAOC,EAEd,MAAO,CACL7C,UAAWZ,EAAEa,OAAS,GACtBxC,KAAMA,EACN8E,cAEJ,CACA,MAAO,CACLvC,UAAWZ,EAAEa,OAAS,GACtBxC,KAAM,CAAC,EACP8E,cACD,GAEL,CACA5B,eAAAA,CAAgBV,EAAO3C,EAAMwF,GAC3B,MAAMP,EAAcC,OAAOC,YAAYD,OAAOE,QAAQI,GAAQ1C,QAAO0B,GAAqB,oBAATA,EAAE,IAA8B,SAATA,EAAE,MACpGiB,EAAU,CAAC,EAiCjB,OAhCA9C,EAAMmC,OAAOY,SAAQ,CAACC,EAAOC,KAC3B,GAAIC,MAAMC,QAAQ9F,EAAK4F,IAAS,CAC9B,MAAMG,EAAaJ,EAAMI,WACzB,GAAIA,EAAY,CACd,MAAMC,EAAMhG,EAAK4F,GACjB,GAAmB,YAAfD,EAAMM,KAAoB,CAE5B,MAAMC,EAAW,GACjB,IAAK,IAAIC,EAAI,EAAGA,EAAIH,EAAIhC,OAAQmC,IAAK,CACnC,MAAMC,EAAQJ,EAAIG,GACZE,EAAM,CAAC,EACb,IAAK,IAAIC,EAAI,EAAGA,EAAIP,EAAW/B,OAAQsC,IAAK,CAE1CD,EADaN,EAAWO,GAAGlH,MACfgH,EAAME,EACpB,CACAJ,EAASK,KAAKF,EAChB,CACAZ,EAAQE,EAAMvG,MAAQ8G,CACxB,KAAO,CAEL,MAAMG,EAAM,CAAC,EACb,IAAK,IAAIF,EAAI,EAAGA,EAAIJ,EAAW/B,OAAQmC,IAAK,CAE1CE,EADaN,EAAWI,GAAG/G,MACf4G,EAAIG,EAClB,CACAV,EAAQE,EAAMvG,MAAQiH,CACxB,CACF,CACF,MACEZ,EAAQE,EAAMvG,MAAQY,EAAK4F,EAC7B,IAEK,CACLlD,UAAWC,EAAMvD,KACjBe,KAAMsF,EACNR,cAEJ,EAOF,MAAMuB,EACJzH,WAAAA,CAAYV,GACVmB,KAAKnB,gBAAkBA,CACzB,CAoBA,eAAMoI,CAENC,EAAI1G,GACF,MAAO2G,EAAOC,SAAkBC,QAAQC,IAAI,CAACtH,KAAKnB,gBAAgBmD,cAAcuF,cAAevH,KAAKnB,gBAAgB2I,YAAYN,EAAI1G,KACpI,OAAOiH,EAAAA,YAAkBL,EAASM,IAAIP,GACxC,CAoBA,gBAAMQ,CAENT,EAAI1G,GACF,OAAOR,KAAKnB,gBAAgB2I,YAAYN,EAAI1G,EAC9C,CAYA,2BAAMoH,GACJ,MAAMT,QAAcnH,KAAKnB,gBAAgBmD,cAAcuF,cACvD,OAAOE,EAAAA,YAAkBN,EAAO,OAClC,EAgBF,MAAMU,EAEJtI,WAAAA,CAAYV,EAAiBqB,EAAUT,IAASC,EAAAA,EAAAA,GAAA,mBADlCoI,EAAAA,GAAelI,OAwB7BF,EAAAA,EAAAA,GAAA,YAUqBG,EAAAA,EAAAA,IAAyBC,SACxClB,EAAsBoB,KAAKnB,gBAAiB,UACvCwB,EAAAA,EAAYC,oBAAoB,CACrCzB,gBAAiBmB,KAAKnB,gBACtB0B,OAAQ,YACRC,KAAM,CAACuH,WAGE/H,KAAKE,SAAS8H,OAAOjH,QAAQ,CACxCkH,QAASF,OAzCX/H,KAAKnB,gBAAkBA,EACvBmB,KAAKE,SAAWA,EAChBF,KAAKP,QAAUA,CACjB,CAYA,SAAMmB,GACJ,OAAIhC,EAAsBoB,KAAKnB,gBAAiB,gBACjCmB,KAAKnB,gBAAgBwC,KAAK,SAAU,KAE5C6G,EAAAA,EAAAA,WAAmClI,KAAKE,SAASU,OAAOqH,SAAW,GAAIjI,KAAKP,QAAQ0I,iBAC7F,E,yGCzjBF,MAAMC,EAQJ7I,WAAAA,CAAYV,EAAiBwJ,IAAO3I,EAAAA,EAAAA,GAAA,mBAPtB4I,EAAAA,GAAoB1I,OAkElCF,EAAAA,EAAAA,GAAA,eAmBwBG,EAAAA,EAAAA,IAAyBC,MAAOyI,EAAoBC,KAI1E,MAAMC,EAAyBD,SAAwBxI,KAAKnB,gBAAgB6J,mBACtEC,EAAkB,IAAIC,EAAAA,EAAgB5I,KAAKnB,iBAC3CwJ,EAAQ3C,OAAOmD,KAAKN,IAC1BO,EAAAA,EAAAA,GAAUT,EAAM7D,OAAQ,8CACxBsE,EAAAA,EAAAA,GAAUT,EAAMU,OAAMC,GAAQhJ,KAAKqI,MAAM/G,SAAS0H,KAAQ,iDAC1D,MAAMC,QAAqBjJ,KAAKkJ,SAC1BC,EAAU,GAEVC,EAAcf,EAAMtD,MAAKiE,GAAiB,UAATA,EAAmB,GAAK,IAC/D,IAAK,IAAIrC,EAAI,EAAGA,EAAIyC,EAAY5E,OAAQmC,IAAK,KAAA0C,EAAAC,EAC3C,MAAMN,EAAOI,EAAYzC,IAClB4C,EAAWC,SAA0BnC,QAAQC,IAAI,CAACD,QAAQC,KAA4B,QAAxB+B,EAAAd,EAAmBS,UAAK,IAAAK,OAAA,EAAxBA,EAA0B9D,KAAIkE,IAAgBC,EAAAA,EAAAA,IAAeD,OAAkB,IAAKpC,QAAQC,KAAsB,QAAlBgC,EAAAL,EAAaD,UAAK,IAAAM,OAAA,EAAlBA,EAAoB/D,KAAIkE,IAAgBC,EAAAA,EAAAA,IAAeD,OAAkB,MACxOE,EAAQJ,EAAUjG,QAAOvB,IAAYyH,EAAiBlI,SAASS,KAC/D6H,EAAWJ,EAAiBlG,QAAOvB,IAAYwH,EAAUjI,SAASS,KAIxE,GAAI6H,EAASpF,OAAS,EAAG,CACvB,MAAM4B,EAAQwD,EAASC,QAAQpB,GAC3BrC,GAAS,IACXwD,EAASE,OAAO1D,EAAO,GACvBwD,EAAS7C,KAAK0B,GAElB,CAMA,GALIkB,EAAMnF,QACRmF,EAAMzD,SAAQnE,IACZoH,EAAQpC,KAAK4B,EAAgBoB,OAAO,YAAa,EAACC,EAAAA,EAAAA,GAAYhB,GAAOjH,IAAU,IAG/E6H,EAASpF,OAAQ,QACe6C,QAAQC,IAAIsC,EAASrE,KAAIxD,GAAW/B,KAAKiK,0BAA0BlI,OACjFmE,SAAQ,CAACgE,EAAoB9D,IAAU+C,EAAQpC,KAAK4B,EAAgBoB,OAAOG,EAAoB,EAACF,EAAAA,EAAAA,GAAYhB,GAAOY,EAASxD,OAClJ,CACF,CACA,OAAO/F,EAAAA,EAAYC,oBAAoB,CACrCzB,gBAAiBmB,KAAKnB,gBACtB0B,OAAQ,YACRC,KAAM,CAAC2I,IACP,MAwBJzJ,EAAAA,EAAAA,GAAA,cAkBuBG,EAAAA,EAAAA,IAAyBC,MAAOkJ,EAAMjH,MAC3D+G,EAAAA,EAAAA,GAAU9I,KAAKqI,MAAM/G,SAAS0H,GAAO,uCAAFmB,OAAyCnB,EAAI,WAChF,MAAMoB,QAAwBV,EAAAA,EAAAA,IAAe3H,GAC7C,OAAO1B,EAAAA,EAAYC,oBAAoB,CACrCzB,gBAAiBmB,KAAKnB,gBACtB0B,OAAQ,YACRC,KAAM,EAACwJ,EAAAA,EAAAA,GAAYhB,GAAOoB,IAC1B,MAGJ1K,EAAAA,EAAAA,GAAA,eAwBwBG,EAAAA,EAAAA,IAAyBC,MAAOkJ,EAAMjH,MAC5D+G,EAAAA,EAAAA,GAAU9I,KAAKqI,MAAM/G,SAAS0H,GAAO,uCAAFmB,OAAyCnB,EAAI,WAChF,MAAMoB,QAAwBV,EAAAA,EAAAA,IAAe3H,GACvCmI,QAA2BlK,KAAKiK,0BAA0BG,GAChE,OAAO/J,EAAAA,EAAYC,oBAAoB,CACrCzB,gBAAiBmB,KAAKnB,gBACtB0B,OAAQ2J,EACR1J,KAAM,EAACwJ,EAAAA,EAAAA,GAAYhB,GAAOoB,IAC1B,KA3MFpK,KAAKnB,gBAAkBA,EACvBmB,KAAKqI,MAAQA,CACf,CAmBA,YAAMa,IACJJ,EAAAA,EAAAA,GAAU9I,KAAKqI,MAAM7D,OAAQ,0CAC7B,MAAM6D,EAAQ,CAAC,EACTzC,EAAUF,OAAOE,QAAQ5F,KAAKqI,OAKpC,aAJOhB,QAAQC,IAAI1B,EAAQL,KAAI8E,IAC7B,IAAK,CAAErB,GAAQqB,EACf,OAAOrK,KAAKY,IAAIoI,EAAK,MAClB9C,SAAQ,CAACoE,EAAMlE,IAAUiC,EAAMzC,EAAQQ,GAAO,IAAMkE,IAClDjC,CACT,CAiBA,SAAMzH,CAAIoI,IACRF,EAAAA,EAAAA,GAAU9I,KAAKqI,MAAM/G,SAAS0H,GAAO,uCAAFmB,OAAyCnB,EAAI,WAChF,MAAM7I,EAAUH,KAAKnB,gBACrB,IAAIK,EAAAA,EAAAA,GAAY,qBAAsBiB,KAAYjB,EAAAA,EAAAA,GAAY,gBAAiBiB,GAAU,CACvF,MAAMoK,GAAWP,EAAAA,EAAAA,GAAYhB,GACvBwB,SAAerK,EAAQkB,KAAK,qBAAsB,CAACkJ,KAAYE,WACrE,aAAapD,QAAQC,IAAIjB,MAAMqE,KAAKrE,MAAMmE,GAAO3B,QAAQtD,KAAIoB,GAAKxG,EAAQkB,KAAK,gBAAiB,CAACkJ,EAAU5D,MAC7G,CACA,MAAM,IAAIpE,MAAM,qHAClB,CA0EA,YAAMoI,CAAOtC,EAAOtG,SACZsF,QAAQC,IAAIe,EAAM9C,KAAIzF,UAC1B,MAAO8K,EAASR,SAAyB/C,QAAQC,IAAI,CAACtH,KAAKY,IAAIoI,IAAOU,EAAAA,EAAAA,IAAe3H,KACrF,IAAK6I,EAAQrF,KAAIP,GAAKA,EAAE6F,gBAAevJ,SAAS8I,EAAgBS,eAC9D,MAAM,IAAIC,EAAAA,EAAiBV,EAAiBpB,EAC9C,IAEJ,CAyEA,+BAAMiB,CAA0BlI,GAC9B,MAAOqI,EAAiBW,SAAuB1D,QAAQC,IAAI,EAACoC,EAAAA,EAAAA,IAAe3H,GAAU/B,KAAKnB,gBAAgB6J,qBAC1G,OAAIqC,EAAcF,gBAAkBT,EAAgBS,cAC3C,eAEF,YACT,E","sources":["../node_modules/@thirdweb-dev/sdk/dist/contract-appuri-8a73f5ec.browser.esm.js","../node_modules/@thirdweb-dev/sdk/dist/contract-roles-80a71d71.browser.esm.js"],"sourcesContent":["import { ai as isExtensionEnabled, c_ as FEATURE_METADATA, K as fetchContractMetadataFromAddress, x as ExtensionNotImplementedError, aZ as EventType, c$ as FEATURE_APPURI } from './index-c67c8d87.browser.esm.js';\nimport { d as buildTransactionFunction, T as Transaction } from './transactions-d1b63e67.browser.esm.js';\nimport { utils } from 'ethers';\nimport { replaceGatewayUrlWithScheme } from '@thirdweb-dev/storage';\n\n/**\n * Type guard for contractWrappers depending on passed feature name\n * @internal\n * @param contractWrapper - The contract wrapper to check\n * @param featureName - The feature name to check\n */\nfunction detectContractFeature(contractWrapper, featureName) {\n  const b = isExtensionEnabled(contractWrapper.abi, featureName, contractWrapper.extensions);\n  return b;\n}\n\n/**\n * @internal\n * @param contractWrapper - The contract wrapper to check\n * @param functionName - The function name to check\n */\nfunction hasFunction(functionName, contractWrapper) {\n  return functionName in contractWrapper.readContract.functions;\n}\n\n/**\n * @internal\n */\n\n/**\n * Handles metadata for a Contract\n * @remarks Read and update metadata for this contract\n * @example\n * ```javascript\n * const contract = await sdk.getContract(\"{{contract_address}}\");\n * const metadata = await contract.metadata.get();\n * await contract.metadata.set({\n *   name: \"My Contract\",\n *   description: \"My contract description\"\n * })\n * ```\n * @public\n */\nclass ContractMetadata {\n  featureName = FEATURE_METADATA.name;\n  constructor(contractWrapper, schema, storage) {\n    this.contractWrapper = contractWrapper;\n    this.schema = schema;\n    this.storage = storage;\n  }\n  /**\n   * @internal\n   */\n  parseOutputMetadata(metadata) {\n    return this.schema.output.parseAsync(metadata);\n  }\n\n  /**\n   * @internal\n   */\n  parseInputMetadata(metadata) {\n    return this.schema.input.parseAsync(metadata);\n  }\n  /**\n   * Get the metadata of this contract\n   * @remarks Get the metadata of a contract\n   * @example\n   * ```javascript\n   * const metadata = await contract.metadata.get();\n   * console.log(metadata);\n   * ```\n   * @public\n   * @returns The metadata of the given contract\n   * @twfeature ContractMetadata\n   */\n  async get() {\n    let data;\n    if (this.supportsContractMetadata(this.contractWrapper)) {\n      const uri = await this.contractWrapper.read(\"contractURI\", []);\n      if (uri && uri.includes(\"://\")) {\n        data = await this.storage.downloadJSON(uri);\n      }\n    }\n    if (!data) {\n      try {\n        // try fetching metadata from bytecode and / or contract itself\n        let contractName;\n        try {\n          if (hasFunction(\"name\", this.contractWrapper)) {\n            contractName = await this.contractWrapper.read(\"name\", []);\n          }\n        } catch (err) {\n          // no-op\n        }\n        let contractSymbol;\n        try {\n          if (hasFunction(\"symbol\", this.contractWrapper)) {\n            contractSymbol = await this.contractWrapper.read(\"symbol\", []);\n          }\n        } catch (err) {\n          // no-op\n        }\n        let publishedMetadata;\n        try {\n          publishedMetadata = await fetchContractMetadataFromAddress(this.contractWrapper.address, this.contractWrapper.getProvider(), this.storage, this.contractWrapper.options);\n        } catch (err) {}\n        data = {\n          name: contractName || publishedMetadata?.name,\n          symbol: contractSymbol,\n          description: publishedMetadata?.info.title\n        };\n      } catch (e) {\n        throw new Error(\"Could not fetch contract metadata\");\n      }\n    }\n    return this.parseOutputMetadata(data);\n  }\n\n  /**\n   * Set the metadata of this contract\n   * @remarks OVERWRITE the metadata of a contract\n   * @example\n   * ```javascript\n   * await contract.metadata.set({\n   *   name: \"My Contract\",\n   *   description: \"My contract description\"\n   * })\n   * ```\n   * @public\n   * @param metadata - the metadata to set\n   * @twfeature ContractMetadata\n   */\n  set = /* @__PURE__ */buildTransactionFunction(async metadata => {\n    const uri = await this._parseAndUploadMetadata(metadata);\n    const wrapper = this.contractWrapper;\n    if (this.supportsContractMetadata(wrapper)) {\n      return Transaction.fromContractWrapper({\n        contractWrapper: this.contractWrapper,\n        method: \"setContractURI\",\n        args: [uri],\n        parse: receipt => {\n          return {\n            receipt,\n            data: this.get\n          };\n        }\n      });\n    } else {\n      throw new ExtensionNotImplementedError(FEATURE_METADATA);\n    }\n  });\n\n  /**\n   * Update the metadata of a contract\n   * @remarks Update the metadata of a contract\n   * @example\n   * ```javascript\n   * await contract.metadata.update({\n   *   description: \"My new contract description\"\n   * })\n   * ```\n   * @public\n   * @param metadata - the metadata to update\n   * @twfeature ContractMetadata\n   * */\n  update = /* @__PURE__ */buildTransactionFunction(async metadata => {\n    return await this.set.prepare({\n      ...(await this.get()),\n      ...metadata\n    });\n  });\n\n  /**\n   *\n   * @internal\n   * @param metadata - the metadata to set\n   * @returns\n   */\n  async _parseAndUploadMetadata(metadata) {\n    const parsedMetadata = await this.parseInputMetadata(metadata);\n    return this.storage.upload(parsedMetadata);\n  }\n  supportsContractMetadata(contractWrapper) {\n    return detectContractFeature(contractWrapper, \"ContractMetadata\");\n  }\n}\n\n/**\n * Listen to Contract events in real time\n * @public\n */\nclass ContractEvents {\n  constructor(contractWrapper) {\n    this.contractWrapper = contractWrapper;\n  }\n\n  /**\n   * Subscribe to transactions in this contract.\n   * @remarks Will emit an \"event\" object containing the transaction status ('submitted' and 'completed') and hash\n   * @example\n   * ```javascript\n   * contract.events.addTransactionListener((event) => {\n   *   console.log(event);\n   * }\n   * ```\n   * @param listener - the callback function that will be called on every transaction\n   * @public\n   */\n  addTransactionListener(listener) {\n    this.contractWrapper.addListener(EventType.Transaction, listener);\n  }\n\n  /**\n   * Remove a transaction listener\n   * @remarks Remove a listener that was added with addTransactionListener\n   * @example\n   * ```javascript\n   * contract.events.removeTransactionListener((event) => {\n   *  console.log(event);\n   * }\n   * ```\n   * @param listener - the callback function to remove\n   * @public\n   */\n  removeTransactionListener(listener) {\n    this.contractWrapper.off(EventType.Transaction, listener);\n  }\n\n  /**\n   * Subscribe to contract events\n   * @remarks You can add a listener for any contract event to run a function when\n   * the event is emitted. For example, if you wanted to listen for a \"TokensMinted\" event,\n   * you could do the following:\n   * @example\n   * ```javascript\n   * contract.events.addEventListener(\"TokensMinted\", (event) => {\n   *   console.log(event);\n   * });\n   * ```\n   * @public\n   * @param eventName - the event name as defined in the contract\n   * @param listener - the callback function that will be called on every new event\n   * @returns A function to un-subscribe from the event\n   */\n  addEventListener(\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  eventName, listener) {\n    // validates event, throws error if not found\n    const event = this.contractWrapper.readContract.interface.getEvent(eventName);\n    const address = this.contractWrapper.address;\n    const filter = {\n      address,\n      topics: [this.contractWrapper.readContract.interface.getEventTopic(event)]\n    };\n    const wrappedListener = log => {\n      const parsedLog = this.contractWrapper.readContract.interface.parseLog(log);\n      listener(this.toContractEvent(parsedLog.eventFragment, parsedLog.args, log));\n    };\n    this.contractWrapper.getProvider().on(filter, wrappedListener);\n    return () => {\n      this.contractWrapper.getProvider().off(filter, wrappedListener);\n    };\n  }\n\n  /**\n   * Listen to all events emitted from this contract\n   *\n   * @example\n   * ```javascript\n   * contract.events.listenToAllEvents((event) => {\n   *   console.log(event.eventName) // the name of the emitted event\n   *   console.log(event.data) // event payload\n   * }\n   * ```\n   * @public\n   * @param listener - the callback function that will be called on every new event\n   * @returns A function that can be called to stop listening to events\n   */\n  listenToAllEvents(listener) {\n    const address = this.contractWrapper.address;\n    const filter = {\n      address\n    };\n    const wrappedListener = log => {\n      try {\n        const parsedLog = this.contractWrapper.readContract.interface.parseLog(log);\n        listener(this.toContractEvent(parsedLog.eventFragment, parsedLog.args, log));\n      } catch (e) {\n        console.error(\"Could not parse event:\", log, e);\n      }\n    };\n    this.contractWrapper.getProvider().on(filter, wrappedListener);\n    return () => {\n      this.contractWrapper.getProvider().off(filter, wrappedListener);\n    };\n  }\n\n  /**\n   * Remove an event listener from this contract\n   * @remarks Remove a listener that was added with addEventListener\n   * @example\n   * ```javascript\n   * contract.events.removeEventListener(\"TokensMinted\", (event) => {\n   *   console.log(event);\n   * });\n   * ```\n   * @public\n   * @param eventName - the event name as defined in the contract\n   * @param listener - the listener to unregister\n   */\n  removeEventListener(\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  eventName, listener) {\n    // validates event, throws error if not found\n    const event = this.contractWrapper.readContract.interface.getEvent(eventName);\n    this.contractWrapper.readContract.off(event.name, listener);\n  }\n\n  /**\n   * Remove all listeners on this contract\n   * @remarks Remove all listeners from a contract\n   * @example\n   * ```javascript\n   * contract.events.removeAllListeners();\n   * ```\n   * @public\n   */\n  removeAllListeners() {\n    this.contractWrapper.readContract.removeAllListeners();\n    const address = this.contractWrapper.address;\n    const filter = {\n      address\n    };\n    this.contractWrapper.getProvider().removeAllListeners(filter);\n  }\n\n  /**\n   * Get All Events\n   * @remarks Get a list of all the events emitted from this contract during the specified time period\n   * @example\n   * ```javascript\n   * // Optionally pass in filters to limit the blocks from which events are retrieved\n   * const filters = {\n   *   fromBlock: 0,\n   *   toBlock: 1000000,\n   * }\n   * const events = await contract.events.getAllEvents(filters);\n   * console.log(events[0].eventName);\n   * console.log(events[0].data);\n   * ```\n   *\n   * @param filters - Specify the from and to block numbers to get events for, defaults to all blocks\n   * @returns The event objects of the events emitted with event names and data for each event\n   */\n  async getAllEvents() {\n    let filters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      fromBlock: 0,\n      toBlock: \"latest\",\n      order: \"desc\"\n    };\n    const events = await this.contractWrapper.readContract.queryFilter({}, filters.fromBlock, filters.toBlock);\n    const orderedEvents = events.sort((a, b) => {\n      return filters.order === \"desc\" ? b.blockNumber - a.blockNumber : a.blockNumber - b.blockNumber;\n    });\n    return this.parseEvents(orderedEvents);\n  }\n\n  /**\n   * Get Events\n   * @remarks Get a list of the events of a specific type emitted from this contract during the specified time period\n   * @example\n   * ```javascript\n   * // The name of the event to get logs for\n   * const eventName = \"Transfer\";\n   *\n   * // Optionally pass in options to limit the blocks from which events are retrieved\n   * const options = {\n   *   fromBlock: 0,\n   *   toBlock: 1000000, // can also pass \"latest\"\n   *   order: \"desc\",\n   *   // Configure event filters (filter on indexed event parameters)\n   *   filters: {\n   *     from: \"0x...\",\n   *     to: \"0x...\"\n   *   }\n   * };\n   *\n   * const events = await contract.events.getEvents(eventName, options);\n   * console.log(events[0].eventName);\n   * console.log(events[0].data);\n   * ```\n   *\n   * @param eventName - The name of the event to get logs for\n   * @param options - Specify the from and to block numbers to get events for, defaults to all blocks. @see EventQueryOptions\n   * @returns The requested event objects with event data\n   */\n  async getEvents(eventName) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n      fromBlock: 0,\n      toBlock: \"latest\",\n      order: \"desc\"\n    };\n    const eventInterface = this.contractWrapper.readContract.interface.getEvent(eventName);\n    const args = options.filters ? eventInterface.inputs.map(e => options.filters[e.name]) : [];\n    const filter = this.contractWrapper.readContract.filters[eventInterface.name](...args);\n    const events = await this.contractWrapper.readContract.queryFilter(filter, options.fromBlock, options.toBlock);\n    const orderedEvents = events.sort((a, b) => {\n      return options.order === \"desc\" ? b.blockNumber - a.blockNumber : a.blockNumber - b.blockNumber;\n    });\n    return this.parseEvents(orderedEvents);\n  }\n  parseEvents(events) {\n    return events.map(e => {\n      const transaction = Object.fromEntries(Object.entries(e).filter(a => typeof a[1] !== \"function\" && a[0] !== \"args\"));\n      if (e.args) {\n        const entries = Object.entries(e.args);\n        const args = entries.slice(entries.length / 2, entries.length);\n        const data = {};\n        for (const [key, value] of args) {\n          data[key] = value;\n        }\n        return {\n          eventName: e.event || \"\",\n          data: data,\n          transaction\n        };\n      }\n      return {\n        eventName: e.event || \"\",\n        data: {},\n        transaction\n      };\n    });\n  }\n  toContractEvent(event, args, rawLog) {\n    const transaction = Object.fromEntries(Object.entries(rawLog).filter(a => typeof a[1] !== \"function\" && a[0] !== \"args\"));\n    const results = {};\n    event.inputs.forEach((param, index) => {\n      if (Array.isArray(args[index])) {\n        const components = param.components;\n        if (components) {\n          const arr = args[index];\n          if (param.type === \"tuple[]\") {\n            // tuple[]\n            const objArray = [];\n            for (let i = 0; i < arr.length; i++) {\n              const tuple = arr[i];\n              const obj = {};\n              for (let j = 0; j < components.length; j++) {\n                const name = components[j].name;\n                obj[name] = tuple[j];\n              }\n              objArray.push(obj);\n            }\n            results[param.name] = objArray;\n          } else {\n            // simple tuple\n            const obj = {};\n            for (let i = 0; i < components.length; i++) {\n              const name = components[i].name;\n              obj[name] = arr[i];\n            }\n            results[param.name] = obj;\n          }\n        }\n      } else {\n        results[param.name] = args[index];\n      }\n    });\n    return {\n      eventName: event.name,\n      data: results,\n      transaction\n    };\n  }\n}\n\n/**\n * Estimates the gas cost of Contract calls\n * @public\n */\nclass GasCostEstimator {\n  constructor(contractWrapper) {\n    this.contractWrapper = contractWrapper;\n  }\n\n  /**\n   * Estimates the cost of gas in native token of the current chain\n   * Pass in the same parameters as the contract's function.\n   * @remarks Estimate the cost of gas in native token of the current chain\n   * @example\n   * ```javascript\n   * const costOfClaim = await nftDrop?.estimator.gasCostOf(\"claim\", [\n   *   \"0x...\", // receiver\n   *   1, // quantity\n   *   \"0x...\", // currency\n   *   1, // price per token\n   *   [], // proofs\n   *   1, // proof max quantity per transaction\n   * ]);\n   * ```\n   * @returns The estimated price in native currency (ETH, MATIC, etc) of calling this function\n   * @public\n   */\n  async gasCostOf(\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  fn, args) {\n    const [price, gasUnits] = await Promise.all([this.contractWrapper.getProvider().getGasPrice(), this.contractWrapper.estimateGas(fn, args)]);\n    return utils.formatEther(gasUnits.mul(price));\n  }\n\n  /**\n   * Estimates the gas limit of a transaction\n   * Pass in the same parameters as the contract's function.\n   * @remarks Estimates the gas limit of a transaction\n   * @example\n   * ```javascript\n   * const gasLimitOfClaim = await nftDrop?.estimator.gasLimitOf(\"claim\", [\n   *   \"0x...\", // receiver\n   *   1, // quantity\n   *   \"0x...\", // currency\n   *   1, // price per token\n   *   [], // proofs\n   *   1, // proof max quantity per transaction\n   * ]);\n   * ```\n   * @returns The estimated gas limit of the transaction\n   * @public\n   */\n  async gasLimitOf(\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  fn, args) {\n    return this.contractWrapper.estimateGas(fn, args);\n  }\n\n  /**\n   * Returns the current gas price in gwei\n   * @remarks Get the current gas price in gwei\n   * @example\n   * ```javascript\n   * const gasCostInGwei = await contract.estimator.currentGasPriceInGwei();\n   * ```\n   * @returns The current gas price in gwei\n   * @public\n   */\n  async currentGasPriceInGwei() {\n    const price = await this.contractWrapper.getProvider().getGasPrice();\n    return utils.formatUnits(price, \"gwei\");\n  }\n}\n\n/**\n * Have an official Application URI for this contract.\n * @remarks Configure an official Application URI for this contract.\n * @example\n * ```javascript\n * const contract = await sdk.getContract(\"{{contract_address}}\");\n * const appURI = await contract.app.get();\n * appURI = \"ipfs://some_ipfs_hash\";\n *\n * await contract.app.set(appURI)\n * ```\n * @public\n */\nclass ContractAppURI {\n  featureName = FEATURE_APPURI.name;\n  constructor(contractWrapper, metadata, storage) {\n    this.contractWrapper = contractWrapper;\n    this.metadata = metadata;\n    this.storage = storage;\n  }\n\n  /**\n   * Get App URI\n   * @returns The appURI (typically an IPFS hash)\n   * @example\n   * ```javascript\n   * const appURI = await contract.app.get();\n   * console.log(appURI) // \"ipfs://some_ipfs_hash\";\n   * ```\n   * @twfeature AppURI\n   */\n  async get() {\n    if (detectContractFeature(this.contractWrapper, \"AppURI\")) {\n      return await this.contractWrapper.read(\"appURI\", []);\n    }\n    return replaceGatewayUrlWithScheme((await this.metadata.get()).app_uri || \"\", this.storage.getGatewayUrls());\n  }\n\n  /**\n   * Set App URI\n   * @param appURI - the uri to set (typically an IPFS hash)\n   * @example\n   * ```javascript\n   * const appURI = \"ipfs://some_ipfs_hash\";\n   * await contract.app.set(appURI);\n   * ```\n   * @twfeature AppURI\n   */\n  set = /* @__PURE__ */buildTransactionFunction(async appURI => {\n    if (detectContractFeature(this.contractWrapper, \"AppURI\")) {\n      return Transaction.fromContractWrapper({\n        contractWrapper: this.contractWrapper,\n        method: \"setAppURI\",\n        args: [appURI]\n      });\n    }\n    return await this.metadata.update.prepare({\n      app_uri: appURI\n    });\n  });\n}\n\nexport { ContractMetadata as C, GasCostEstimator as G, ContractEvents as a, ContractAppURI as b, detectContractFeature as d, hasFunction as h };\n","import invariant from 'tiny-invariant';\nimport { d0 as FEATURE_PERMISSIONS, H as getRoleHash, aL as resolveAddress, o as MissingRoleError } from './index-c67c8d87.browser.esm.js';\nimport { h as hasFunction } from './contract-appuri-8a73f5ec.browser.esm.js';\nimport { d as buildTransactionFunction, T as Transaction } from './transactions-d1b63e67.browser.esm.js';\nimport { C as ContractEncoder } from './fetchCurrencyValue-ca929de6.browser.esm.js';\n\n/**\n * Handle contract permissions\n * @remarks Configure roles and permissions for a contract, to restrict certain actions.\n * @example\n * ```javascript\n * const contract = await sdk.getContract(\"{{contract_address}}\");\n * const rolesAndMembers = await contract.roles.getAll();\n * await contract.roles.grantRole(\"admin\", \"0x...\");\n * ```\n * @public\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars -- TO BE REMOVED IN V4\nclass ContractRoles {\n  featureName = FEATURE_PERMISSIONS.name;\n\n  /**\n   * @internal\n   * @remarks This is used for typing inside react hooks which is why it has to be public.\n   */\n\n  constructor(contractWrapper, roles) {\n    this.contractWrapper = contractWrapper;\n    this.roles = roles;\n  }\n\n  /** **************************\n   * READ FUNCTIONS\n   ****************************/\n\n  /**\n   * Get all members of all roles\n   * @remarks See {@link ContractRoles.get} to get a list of addresses that are members of a specific role.\n   * @example\n   * ```javascript\n   * const rolesAndMembers = await contract.roles.getAll();\n   * ```\n   * @returns A record of {@link Role}s to lists of addresses that are members of the given role.\n   * @throws If the contract does not support roles this will throw an error.\n   *\n   * @public\n   * @twfeature PermissionsEnumerable\n   */\n  async getAll() {\n    invariant(this.roles.length, \"this contract has no support for roles\");\n    const roles = {};\n    const entries = Object.entries(this.roles);\n    (await Promise.all(entries.map(_ref => {\n      let [, role] = _ref;\n      return this.get(role);\n    }))).forEach((item, index) => roles[entries[index][1]] = item);\n    return roles;\n  }\n\n  /**\n   * Get all members of a specific role\n   * @remarks See {@link ContractRoles.getAll} to get get a list of addresses for all supported roles on the contract.\n   * @param role - The Role to to get a memberlist for.\n   * @returns The list of addresses that are members of the specific role.\n   * @throws If you are requesting a role that does not exist on the contract this will throw an error.\n   *\n   * @example Say you want to get the list of addresses that are members of the minter role.\n   * ```javascript\n   * const minterAddresses = await contract.roles.get(\"minter\");\n   * ```\n   *\n   * @public\n   * @twfeature Permissions\n   */\n  async get(role) {\n    invariant(this.roles.includes(role), `this contract does not support the \"${role}\" role`);\n    const wrapper = this.contractWrapper;\n    if (hasFunction(\"getRoleMemberCount\", wrapper) && hasFunction(\"getRoleMember\", wrapper)) {\n      const roleHash = getRoleHash(role);\n      const count = (await wrapper.read(\"getRoleMemberCount\", [roleHash])).toNumber();\n      return await Promise.all(Array.from(Array(count).keys()).map(i => wrapper.read(\"getRoleMember\", [roleHash, i])));\n    }\n    throw new Error(\"Contract does not support enumerating roles. Please implement IPermissionsEnumerable to unlock this functionality.\");\n  }\n\n  /**\n   * Overwrite the list of members for specific roles\n   *\n   * @remarks Every role in the list will be overwritten with the new list of addresses provided with them.\n   * If you want to add or remove addresses for a single address use {@link ContractRoles.grant} and {@link ContractRoles.revoke} respectively instead.\n   * @param rolesWithAddresses - A record of {@link Role}s to lists of addresses that should be members of the given role.\n   * @throws If you are requesting a role that does not exist on the contract this will throw an error.\n   * @example Say you want to overwrite the list of addresses that are members of the minter role.\n   * ```javascript\n   * const minterAddresses = await contract.roles.get(\"minter\");\n   * await contract.roles.setAll({\n   *  minter: []\n   * });\n   * console.log(await contract.roles.get(\"minter\")); // No matter what members had the role before, the new list will be set to []\n   * ```\n   * @public\n   * @twfeature Permissions\n   *\n   * */\n  setAll = /* @__PURE__ */buildTransactionFunction(async (rolesWithAddresses, actingAddress) => {\n    // if we are removing multiple roles, we need to allways remove the connected wallet address *last*\n    // this is so we don't renounce (i.e.)  admin role first and then try to revoke someone else's (i.e.) admin role after (which will revert the entire txn because we are no longer an admin)\n    // if it is explicitly passed in (i.e. for estimation) we use that value, otherwise we get it from the connected signer\n    const connectedWalletAddress = actingAddress || (await this.contractWrapper.getSignerAddress());\n    const contractEncoder = new ContractEncoder(this.contractWrapper);\n    const roles = Object.keys(rolesWithAddresses);\n    invariant(roles.length, \"you must provide at least one role to set\");\n    invariant(roles.every(role => this.roles.includes(role)), \"this contract does not support the given role\");\n    const currentRoles = await this.getAll();\n    const encoded = [];\n    // add / remove admin role at the end so we don't revoke admin then grant\n    const sortedRoles = roles.sort(role => role === \"admin\" ? 1 : -1);\n    for (let i = 0; i < sortedRoles.length; i++) {\n      const role = sortedRoles[i];\n      const [addresses, currentAddresses] = await Promise.all([Promise.all(rolesWithAddresses[role]?.map(addressOrEns => resolveAddress(addressOrEns)) || []), Promise.all(currentRoles[role]?.map(addressOrEns => resolveAddress(addressOrEns)) || [])]);\n      const toAdd = addresses.filter(address => !currentAddresses.includes(address));\n      const toRemove = currentAddresses.filter(address => !addresses.includes(address));\n\n      // if we're removing more than one address we have to make sure we always remove the *connected* (acting) wallet address first\n      // otherwise we'll revoke the connected wallet address and then try to revoke someone else's address which will revert the entire txn\n      if (toRemove.length > 1) {\n        const index = toRemove.indexOf(connectedWalletAddress);\n        if (index > -1) {\n          toRemove.splice(index, 1);\n          toRemove.push(connectedWalletAddress);\n        }\n      }\n      if (toAdd.length) {\n        toAdd.forEach(address => {\n          encoded.push(contractEncoder.encode(\"grantRole\", [getRoleHash(role), address]));\n        });\n      }\n      if (toRemove.length) {\n        const revokeFunctionNames = await Promise.all(toRemove.map(address => this.getRevokeRoleFunctionName(address)));\n        revokeFunctionNames.forEach((revokeFunctionName, index) => encoded.push(contractEncoder.encode(revokeFunctionName, [getRoleHash(role), toRemove[index]])));\n      }\n    }\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"multicall\",\n      args: [encoded]\n    });\n  });\n\n  /**\n   * Throws an error if an address is missing the roles specified.\n   *\n   * @param roles - The roles to check\n   * @param address - The address to check\n   *\n   * @internal\n   */\n  async verify(roles, address) {\n    await Promise.all(roles.map(async role => {\n      const [members, resolvedAddress] = await Promise.all([this.get(role), resolveAddress(address)]);\n      if (!members.map(a => a.toLowerCase()).includes(resolvedAddress.toLowerCase())) {\n        throw new MissingRoleError(resolvedAddress, role);\n      }\n    }));\n  }\n\n  /** **************************\n   * WRITE FUNCTIONS\n   ****************************/\n\n  /**\n   * Grant a role to a specific address\n   *\n   * @remarks Make sure you are sure you want to grant the role to the address.\n   *\n   * @example\n   * ```javascript\n   * await contract.roles.grant(\"minter\", \"{{wallet_address}}\");\n   * ```\n   *\n   * @param role - The {@link Role} to grant to the address\n   * @param address - The address to grant the role to\n   * @returns The transaction receipt\n   * @throws If you are trying to grant does not exist on the contract this will throw an error.\n   *\n   * @public\n   * @twfeature Permissions\n   */\n  grant = /* @__PURE__ */buildTransactionFunction(async (role, address) => {\n    invariant(this.roles.includes(role), `this contract does not support the \"${role}\" role`);\n    const resolvedAddress = await resolveAddress(address);\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"grantRole\",\n      args: [getRoleHash(role), resolvedAddress]\n    });\n  });\n\n  /**\n   * Revoke a role from a specific address\n   *\n   * @remarks\n   *\n   * -- Caution --\n   *\n   * This will let you remove yourself from the role, too.\n   * If you remove yourself from the admin role, you will no longer be able to administer the contract.\n   * There is no way to recover from this.\n   *\n   * @example\n   * ```javascript\n   * await contract.roles.revoke(\"minter\", \"{{wallet_address}}\");\n   * ```\n   *\n   * @param role - The {@link Role} to revoke\n   * @param address - The address to revoke the role from\n   * @returns The transaction receipt\n   * @throws If you are trying to revoke does not exist on the module this will throw an error.\n   *\n   * @public\n   * @twfeature Permissions\n   */\n  revoke = /* @__PURE__ */buildTransactionFunction(async (role, address) => {\n    invariant(this.roles.includes(role), `this contract does not support the \"${role}\" role`);\n    const resolvedAddress = await resolveAddress(address);\n    const revokeFunctionName = await this.getRevokeRoleFunctionName(resolvedAddress);\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: revokeFunctionName,\n      args: [getRoleHash(role), resolvedAddress]\n    });\n  });\n\n  /** **************************\n   * PRIVATE FUNCTIONS\n   ****************************/\n\n  async getRevokeRoleFunctionName(address) {\n    const [resolvedAddress, signerAddress] = await Promise.all([resolveAddress(address), this.contractWrapper.getSignerAddress()]);\n    if (signerAddress.toLowerCase() === resolvedAddress.toLowerCase()) {\n      return \"renounceRole\";\n    }\n    return \"revokeRole\";\n  }\n}\n\nexport { ContractRoles as C };\n"],"names":["detectContractFeature","contractWrapper","featureName","isExtensionEnabled","abi","extensions","hasFunction","functionName","readContract","functions","ContractMetadata","constructor","schema","storage","_defineProperty","FEATURE_METADATA","name","buildTransactionFunction","async","uri","this","_parseAndUploadMetadata","metadata","wrapper","supportsContractMetadata","Transaction","fromContractWrapper","method","args","parse","receipt","data","get","ExtensionNotImplementedError","set","prepare","parseOutputMetadata","output","parseAsync","parseInputMetadata","input","read","includes","downloadJSON","_publishedMetadata","_publishedMetadata2","contractName","contractSymbol","publishedMetadata","err","fetchContractMetadataFromAddress","address","getProvider","options","symbol","description","info","title","e","Error","parsedMetadata","upload","ContractEvents","addTransactionListener","listener","addListener","EventType","removeTransactionListener","off","addEventListener","eventName","event","interface","getEvent","filter","topics","getEventTopic","wrappedListener","log","parsedLog","parseLog","toContractEvent","eventFragment","on","listenToAllEvents","console","error","removeEventListener","removeAllListeners","getAllEvents","filters","arguments","length","undefined","fromBlock","toBlock","order","orderedEvents","queryFilter","sort","a","b","blockNumber","parseEvents","getEvents","eventInterface","inputs","map","events","transaction","Object","fromEntries","entries","slice","key","value","rawLog","results","forEach","param","index","Array","isArray","components","arr","type","objArray","i","tuple","obj","j","push","GasCostEstimator","gasCostOf","fn","price","gasUnits","Promise","all","getGasPrice","estimateGas","utils","mul","gasLimitOf","currentGasPriceInGwei","ContractAppURI","FEATURE_APPURI","appURI","update","app_uri","replaceGatewayUrlWithScheme","getGatewayUrls","ContractRoles","roles","FEATURE_PERMISSIONS","rolesWithAddresses","actingAddress","connectedWalletAddress","getSignerAddress","contractEncoder","ContractEncoder","keys","invariant","every","role","currentRoles","getAll","encoded","sortedRoles","_rolesWithAddresses$r","_currentRoles$role","addresses","currentAddresses","addressOrEns","resolveAddress","toAdd","toRemove","indexOf","splice","encode","getRoleHash","getRevokeRoleFunctionName","revokeFunctionName","concat","resolvedAddress","_ref","item","roleHash","count","toNumber","from","verify","members","toLowerCase","MissingRoleError","signerAddress"],"sourceRoot":""}