"use strict";(self.webpackChunkclient=self.webpackChunkclient||[]).push([[4749],{34749:(t,e,a)=>{a.d(e,{D:()=>w});var r=a(64572),i=a(68624),s=a(49716),o=a(6222),n=a(2257),l=a(75422),c=a(83374),p=a(78262),h=a.n(p),d=a(99816),m=a(84888),u=a(34243),g=a(40774),C=a(24115);class w{constructor(t,e,a){(0,r.Z)(this,"set",(0,C.d)((()=>{var t=this;return async function(e){let a=arguments.length>1&&void 0!==arguments[1]&&arguments[1],r=e;if(t.isLegacySinglePhaseDrop(t.contractWrapper)||t.isNewSinglePhaseDrop(t.contractWrapper))if(a=!0,0===e.length)r=[{startTime:new Date(0),currencyAddress:i.d,price:0,maxClaimableSupply:0,maxClaimablePerWallet:0,waitInSeconds:0,merkleRootHash:s.hexZeroPad([0],32),snapshot:[]}];else if(e.length>1)throw new Error("Single phase drop contract cannot have multiple claim conditions, only one is allowed");(t.isNewSinglePhaseDrop(t.contractWrapper)||t.isNewMultiphaseDrop(t.contractWrapper))&&r.forEach((t=>{var e;if(t.snapshot&&t.snapshot.length>0&&(void 0===t.maxClaimablePerWallet||"unlimited"===t.maxClaimablePerWallet))throw new Error("maxClaimablePerWallet must be set to a specific value when an allowlist is set.\nExample: Set it to 0 to only allow addresses in the allowlist to claim the amount specified in the allowlist.\ncontract.claimConditions.set([{ snapshot: [{ address: '0x...', maxClaimable: 1 }], maxClaimablePerWallet: 0 }])");if(t.snapshot&&t.snapshot.length>0&&"0"===(null===(e=t.maxClaimablePerWallet)||void 0===e?void 0:e.toString())&&0===t.snapshot.map((t=>{return"string"===typeof t?0:Number((null===(e=t.maxClaimable)||void 0===e?void 0:e.toString())||0);var e})).reduce(((t,e)=>t+e),0))throw new Error("maxClaimablePerWallet is set to 0, and all addresses in the allowlist have max claimable 0. This means that no one can claim.")}));const{snapshotInfos:o,sortedConditions:n}=await(0,m.H)(r,await t.getTokenDecimals(),t.contractWrapper.getProvider(),t.storage,t.getSnapshotFormatVersion()),l={};o.forEach((t=>{l[t.merkleRoot]=t.snapshotUri}));const c=await t.metadata.get(),p=[];if(!h()(c.merkle,l)){const e=await t.metadata.parseInputMetadata({...c,merkle:l}),a=await t.metadata._parseAndUploadMetadata(e);if(!(0,g.h)("setContractURI",t.contractWrapper))throw new Error("Setting a merkle root requires implementing ContractMetadata in your contract to support storing a merkle root.");{const e=new u.C(t.contractWrapper);p.push(e.encode("setContractURI",[a]))}}const d=t.contractWrapper,w=new u.C(d);if(t.isLegacySinglePhaseDrop(d)){const t=new u.C(d);p.push(t.encode("setClaimConditions",[(0,m.I)(n[0]),a]))}else if(t.isLegacyMultiPhaseDrop(d))p.push(w.encode("setClaimConditions",[n.map(m.I),a]));else if(t.isNewSinglePhaseDrop(d))p.push(w.encode("setClaimConditions",[(0,m.J)(n[0]),a]));else{if(!t.isNewMultiphaseDrop(d))throw new Error("Contract does not support claim conditions");p.push(w.encode("setClaimConditions",[n.map(m.J),a]))}if((0,g.h)("multicall",t.contractWrapper))return C.T.fromContractWrapper({contractWrapper:t.contractWrapper,method:"multicall",args:[p]});throw new Error("Contract does not support multicall")}})())),(0,r.Z)(this,"update",(0,C.d)((async(t,e)=>{const a=await this.getAll(),r=await(0,m.K)(t,e,a);return await this.set.prepare(r)}))),this.storage=a,this.contractWrapper=t,this.metadata=e}async getActive(t){const[e,a,r]=await Promise.all([this.get(),this.metadata.get(),this.getTokenDecimals()]);return await(0,m.y)(e,r,this.contractWrapper.getProvider(),a.merkle||{},this.storage,(null===t||void 0===t?void 0:t.withAllowList)||!1)}async get(t){if(this.isLegacySinglePhaseDrop(this.contractWrapper)){const t=await this.contractWrapper.read("claimCondition",[]);return(0,m.z)(t)}if(this.isLegacyMultiPhaseDrop(this.contractWrapper)){const e=void 0!==t?t:await this.contractWrapper.read("getActiveClaimConditionId",[]),a=await this.contractWrapper.read("getClaimConditionById",[e]);return(0,m.z)(a)}if(this.isNewSinglePhaseDrop(this.contractWrapper)){const t=await this.contractWrapper.read("claimCondition",[]);return(0,m.A)(t)}if(this.isNewMultiphaseDrop(this.contractWrapper)){const e=void 0!==t?t:await this.contractWrapper.read("getActiveClaimConditionId",[]),a=await this.contractWrapper.read("getClaimConditionById",[e]);return(0,m.A)(a)}throw new Error("Contract does not support claim conditions")}async getAll(t){if(this.isLegacyMultiPhaseDrop(this.contractWrapper)||this.isNewMultiphaseDrop(this.contractWrapper)){const[e,a]=await this.contractWrapper.read("claimCondition",[]),r=e.toNumber(),i=a.toNumber(),s=[];for(let t=r;t<r+i;t++)s.push(this.get(t));const[o,n,...l]=await Promise.all([this.metadata.get(),this.getTokenDecimals(),...s]);return Promise.all(l.map((e=>(0,m.y)(e,n,this.contractWrapper.getProvider(),o.merkle,this.storage,(null===t||void 0===t?void 0:t.withAllowList)||!1))))}return[await this.getActive(t)]}async canClaim(t,e){return e&&(e=await(0,d.aL)(e)),0===(await this.getClaimIneligibilityReasons(t,e)).length}async getClaimIneligibilityReasons(t,e){const r=[];let i,c;if(void 0===e)try{e=await this.contractWrapper.getSignerAddress()}catch(f){console.warn("failed to get signer address",f)}if(!e)return[m.C.NoWallet];const[p,h]=await Promise.all([(0,d.aL)(e),this.getTokenDecimals()]),g=o.parseUnits(d.cv.parse(t),h);try{c=await this.getActive()}catch(f){return(0,d.B)(f,"!CONDITION")||(0,d.B)(f,"no active mint condition")?(r.push(m.C.NoClaimConditionSet),r):(console.warn("failed to get active claim condition",f),r.push(m.C.Unknown),r)}if("unlimited"!==c.availableSupply){if(o.parseUnits(c.availableSupply,h).lt(g))return r.push(m.C.NotEnoughSupply),r}const C=s.stripZeros(c.merkleRootHash).length>0;let w=null;if(C){if(w=await this.getClaimerProofs(p),!w&&(this.isLegacySinglePhaseDrop(this.contractWrapper)||this.isLegacyMultiPhaseDrop(this.contractWrapper)))return r.push(m.C.AddressNotAllowed),r;if(w)try{const e=await this.prepareClaim(t,!1,h,p);let a;if(this.isLegacyMultiPhaseDrop(this.contractWrapper)){if(i=await this.contractWrapper.read("getActiveClaimConditionId",[]),[a]=await this.contractWrapper.read("verifyClaimMerkleProof",[i,p,t,e.proofs,e.maxClaimable]),!a)return r.push(m.C.AddressNotAllowed),r}else if(this.isLegacySinglePhaseDrop(this.contractWrapper)){if([a]=await this.contractWrapper.read("verifyClaimMerkleProof",[p,t,{proof:e.proofs,maxQuantityInAllowlist:e.maxClaimable}]),!a)return r.push(m.C.AddressNotAllowed),r}else this.isNewSinglePhaseDrop(this.contractWrapper)?await this.contractWrapper.read("verifyClaim",[p,t,e.currencyAddress,e.price,{proof:e.proofs,quantityLimitPerWallet:e.maxClaimable,currency:e.currencyAddressInProof,pricePerToken:e.priceInProof}]):this.isNewMultiphaseDrop(this.contractWrapper)&&(i=await this.contractWrapper.read("getActiveClaimConditionId",[]),await this.contractWrapper.read("verifyClaim",[i,p,t,e.currencyAddress,e.price,{proof:e.proofs,quantityLimitPerWallet:e.maxClaimable,currency:e.currencyAddressInProof,pricePerToken:e.priceInProof}]))}catch(y){console.warn("Merkle proof verification failed:","reason"in y?y.reason:y);switch(y.reason){case"!Qty":r.push(m.C.OverMaxClaimablePerWallet);break;case"!PriceOrCurrency":r.push(m.C.WrongPriceOrCurrency);break;case"!MaxSupply":r.push(m.C.NotEnoughSupply);break;case"cant claim yet":r.push(m.C.ClaimPhaseNotStarted);break;default:r.push(m.C.AddressNotAllowed)}return r}}if(this.isNewSinglePhaseDrop(this.contractWrapper)||this.isNewMultiphaseDrop(this.contractWrapper)){let t=n.O$.from(0),e=(0,m.D)(c.maxClaimablePerWallet,h);try{t=await this.getSupplyClaimedByWallet(p)}catch(y){}if(w&&(e=(0,m.D)(w.maxClaimable,h)),e.gt(0)&&e.lt(t.add(g)))return r.push(m.C.OverMaxClaimablePerWallet),r;if((!C||C&&!w)&&(e.lte(t)||e.eq(0)))return r.push(m.C.AddressNotAllowed),r}if(this.isLegacySinglePhaseDrop(this.contractWrapper)||this.isLegacyMultiPhaseDrop(this.contractWrapper)){let[t,e]=[n.O$.from(0),n.O$.from(0)];this.isLegacyMultiPhaseDrop(this.contractWrapper)?(i=await this.contractWrapper.read("getActiveClaimConditionId",[]),[t,e]=await this.contractWrapper.read("getClaimTimestamp",[i,p])):this.isLegacySinglePhaseDrop(this.contractWrapper)&&([t,e]=await this.contractWrapper.read("getClaimTimestamp",[p]));const a=n.O$.from(Date.now()).div(1e3);if(t.gt(0)&&a.lt(e))return e.eq(l.Bz)?r.push(m.C.AlreadyClaimed):r.push(m.C.WaitBeforeNextClaimTransaction),r}if(c.price.gt(0)&&(0,d.d4)()){const e=c.price.mul(n.O$.from(t)),i=this.contractWrapper.getProvider();if((0,u.i)(c.currencyAddress)){(await i.getBalance(p)).lt(e)&&r.push(m.C.NotEnoughTokens)}else{const t=(await Promise.resolve().then(a.t.bind(a,49242,19))).default,s=new d.cq(i,c.currencyAddress,t,{},this.storage);(await s.read("balanceOf",[p])).lt(e)&&r.push(m.C.NotEnoughTokens)}}return r}async getClaimerProofs(t,e){const a=(await this.get(e)).merkleRoot;if(s.stripZeros(a).length>0){const[e,r]=await Promise.all([this.metadata.get(),(0,d.aL)(t)]);return await(0,m.f)(r,a.toString(),e.merkle,this.contractWrapper.getProvider(),this.storage,this.getSnapshotFormatVersion())}return null}async getSupplyClaimedByWallet(t){const e=await(0,d.aL)(t);if(this.isNewSinglePhaseDrop(this.contractWrapper))return await this.contractWrapper.read("getSupplyClaimedByWallet",[e]);if(this.isNewMultiphaseDrop(this.contractWrapper)){const t=await this.contractWrapper.read("getActiveClaimConditionId",[]);return await this.contractWrapper.read("getSupplyClaimedByWallet",[t,e])}throw new Error("This contract does not support the getSupplyClaimedByWallet function")}async getTokenDecimals(){return(0,g.d)(this.contractWrapper,"ERC20")?this.contractWrapper.read("decimals",[]):Promise.resolve(0)}async prepareClaim(t,e){let a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=arguments.length>3?arguments[3]:void 0;const[i,s]=await Promise.all([r||this.contractWrapper.getSignerAddress(),this.getActive()]);return(0,m.E)(i,t,s,(async()=>(await this.metadata.get()).merkle),a,this.contractWrapper,this.storage,e,this.getSnapshotFormatVersion())}async getClaimArguments(t,e,a){const r=await(0,d.aL)(t);return this.isLegacyMultiPhaseDrop(this.contractWrapper)?[r,e,a.currencyAddress,a.price,a.proofs,a.maxClaimable]:this.isLegacySinglePhaseDrop(this.contractWrapper)?[r,e,a.currencyAddress,a.price,{proof:a.proofs,maxQuantityInAllowlist:a.maxClaimable},c.Y0("")]:[r,e,a.currencyAddress,a.price,{proof:a.proofs,quantityLimitPerWallet:a.maxClaimable,pricePerToken:a.priceInProof,currency:a.currencyAddressInProof},c.Y0("")]}async getClaimTransaction(t,e,a){if(null!==a&&void 0!==a&&a.pricePerToken)throw new Error("Price per token is be set via claim conditions by calling `contract.erc721.claimConditions.set()`");const r=await this.prepareClaim(e,void 0===(null===a||void 0===a?void 0:a.checkERC20Allowance)||a.checkERC20Allowance,await this.getTokenDecimals());return C.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"claim",args:await this.getClaimArguments(t,e,r),overrides:r.overrides})}isNewSinglePhaseDrop(t){return(0,g.d)(t,"ERC721ClaimConditionsV2")||(0,g.d)(t,"ERC20ClaimConditionsV2")}isNewMultiphaseDrop(t){return(0,g.d)(t,"ERC721ClaimPhasesV2")||(0,g.d)(t,"ERC20ClaimPhasesV2")}isLegacySinglePhaseDrop(t){return(0,g.d)(t,"ERC721ClaimConditionsV1")||(0,g.d)(t,"ERC20ClaimConditionsV1")}isLegacyMultiPhaseDrop(t){return(0,g.d)(t,"ERC721ClaimPhasesV1")||(0,g.d)(t,"ERC20ClaimPhasesV1")}getSnapshotFormatVersion(){return this.isLegacyMultiPhaseDrop(this.contractWrapper)||this.isLegacySinglePhaseDrop(this.contractWrapper)?m.F.V1:m.F.V2}}}}]);
//# sourceMappingURL=4749.7795a753.chunk.js.map